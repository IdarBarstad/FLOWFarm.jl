var documenterSearchIndex = {"docs":
[{"location":"How_to/#How-to-Guide","page":"How-to Guide","title":"How-to Guide","text":"","category":"section"},{"location":"How_to/#Multi-threading","page":"How-to Guide","title":"Multi-threading","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Multi-threading is available for the calculation of annual energy production (AEP). It can be enabled as follows in a bash terminal in Linux/OS prior to launching a julia session:","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"export JULIA_NUM_THREADS=<number of threads>","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"For enabling multi-threading on other shells/systems please see the julia parallel-computing docs here: https://docs.julialang.org/en/v1/manual/parallel-computing/.","category":"page"},{"location":"How_to/#Distributed-Processing","page":"How-to Guide","title":"Distributed Processing","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Distributed parallel processing is available for the calculation of annual energy production (AEP). ","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"You may have to add using Distributed to your julia script and use the @everywhere macro  in front of any functions you define that all processors will need access to. For an example,  see example_opt_6_38turb_round_distributed.jl.","category":"page"},{"location":"How_to/#Using-Distributed-Processing-without-an-HPC-Cluster-Manager-(e.g.-on-your-local-system)","page":"How-to Guide","title":"Using Distributed Processing without an HPC Cluster Manager (e.g. on your local system)","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Distributed parallel processing can be enabled as follows when launching a julia session:","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"julia -p <number of processors>","category":"page"},{"location":"How_to/#Using-Distributed-Processing-with-an-HPC-Cluster-Manager-(e.g.-SLURM)","page":"How-to Guide","title":"Using Distributed Processing with an HPC Cluster Manager (e.g. SLURM)","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"The -p option to the julia call is unnecessary when running with a cluster manager.  To work with cluster managers, add the following to your julia script (this example is for  SLURM, but other managers are available as well):","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"using Distributed\nusing ClusterManagers\n\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])-1))\n@everywhere import FLOWFarm; const ff = FLOWFarm","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Also include the @everywhere macro in front of any function definitions or include statements in your julia script that all processors will need access to.","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Your SLURM job script should look something like this:","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"#!/bin/bash -l\n#SBATCH --ntasks=100\n#SBATCH --mem-per-cpu=1024M   # memory per CPU core\n#SBATCH --time=01:00:00 # time=HH:MM:SS\n#SBATCH -J \"Your job name here\"   # job name\n\nmodule load julia\n\njulia julia_script.jl","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"References For more information on using julia in a distributed environment, please see https://docs.julialang.org/en/v1/manual/parallel-computing/.","category":"page"},{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"Modules = [FLOWFarm]","category":"page"},{"location":"Reference/#FLOWFarm.DiscretizedWindResource","page":"Reference","title":"FLOWFarm.DiscretizedWindResource","text":"DiscritizedWindResource(wind_directions, wind_speeds, wind_probabilities, measurement_heights, air_density, ti_model, wind_shear_model)\n\nStruct defining a wind resource\n\nArguments\n\nwind_directions::Array{Float,1}(Nstates): an array of wind directions corresponding to each wind farm state in radians\nwind_speeds::Array{Float,1}(Nstates): an array of wind speeds corresponding to each wind farm state in meters/second\nwind_probabilities::Array{Float,1}(Nstates): an array of probabilities corresponding to each wind farm state with values in [0,1]\nmeasurement_heights::Array{Float,1}(Nstates): an array of measurement heights corresponding to each wind farm state\nair_density::Float: the air density\nambient_ti::Array{Float,1}: an array of the ambient turbulence intensity for each wind direction\nwind_shear_model::Array{AbstractWindShearModel}(1): contains a struct defining the desired turbulence intensity model\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussOriginal","page":"Reference","title":"FLOWFarm.GaussOriginal","text":"GaussOriginal(k_star)\n\nContainer for parameters related to the origina Gaussian deficit model presented by Bastankhah and Porte-Agel 2014\n\nArguments\n\nk_star::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.075\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussSimple","page":"Reference","title":"FLOWFarm.GaussSimple","text":"GaussSimple(k, wec_factor)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nk::Float: parameter controlling the spread of the wake\nwec_factor::Array{Float}: parameter artificial wake spreading for wake expansion continuation (WEC) optimization\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYaw","page":"Reference","title":"FLOWFarm.GaussYaw","text":"GaussYaw(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.\nvertical_spread_rate::Float: parameter controlling the vertical spread of the deficit model. Default value is 0.022.\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawDeflection","page":"Reference","title":"FLOWFarm.GaussYawDeflection","text":"GaussYawDeflection(horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)\n\nContainer for parameters related to the Gaussian deflection model presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.\nvertical_spread_rate::Float: parameter controlling the vertical spread of the deficit model. Default value is 0.022.\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawVariableSpread","page":"Reference","title":"FLOWFarm.GaussYawVariableSpread","text":"GaussYawVariableSpread(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016     and the farm model presented by Niayifar and Porte-Agel in 2016.\n\nArguments\n\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawVariableSpreadDeflection","page":"Reference","title":"FLOWFarm.GaussYawVariableSpreadDeflection","text":"GaussYawDeflectionVariableSpread(alpha_star, beta_star, k1, k2, wec_factor)\n\nContainer for parameters related to the Gaussian deflection model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\nk1::Float: first parameter tuning wake spread as based on turbulence intensity\nk2::Float: second parameter tuning wake spread as based on turbulence intensity\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JensenCosine","page":"Reference","title":"FLOWFarm.JensenCosine","text":"JensenCosine(alpha)\n\nContainer for parameters related to the Jensen Cosine deficit model\n\nArguments\n\nalpha::Float: parameter controlling the wake deficit decay rate. Default value is 0.1\nbeta::Float: parameter controlling the width of the cosine function. Default value is 20.0 deg., given in radians.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JensenTopHat","page":"Reference","title":"FLOWFarm.JensenTopHat","text":"JensenTopHat(alpha)\n\nContainer for parameters related to the Jensen Top Hat deficit model\n\nArguments\n\nalpha::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JiminezYawDeflection","page":"Reference","title":"FLOWFarm.JiminezYawDeflection","text":"JiminezYawDeflection(horizontal_spread_rate)\n\nContainer for parameters related to the Jiminez deflection model\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.Levelized","page":"Reference","title":"FLOWFarm.Levelized","text":"Levelized(TCC, BOS, FC, FCR, OpEx)\n\nContainer for parameters related to the Levelized Cost of Energy model (NREL 2016 Cost of Wind Energy)\n\nArguments\n\nArguments\n\nTCC::Float: Turbine Capital Cost not including the tower module\nBOS::Float: Balance of System (Costs outside of turbine i.e. operation and maintenance)\nFC::Float: Financial Costs including construction and contingency\nFCR::Float: Fixed Charge Rate\nOpEx::Float: Operational Expenditures\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelMaxTI","page":"Reference","title":"FLOWFarm.LocalTIModelMaxTI","text":"LocalTIModelMaxTI(astar, bstar, k1, k2)\n\nCalculate local turbulence intensity using the model presented in Niayifar and  Porte Agel (2015, 2016)\n\nArguments\n\nastar::Float: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model\nbstar::Float: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model\nk1::Float: slope of k vs TI curve\nk2::Float: vertical offset of k vs TI curve\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelNoLocalTI","page":"Reference","title":"FLOWFarm.LocalTIModelNoLocalTI","text":"LocalTIModelNoLocalTI()\n\nDon't calculate local turbulence intensity. Ambient TI will be used instead for all points\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.MultiZone","page":"Reference","title":"FLOWFarm.MultiZone","text":"MultiZone(me, ke, MU, aU, bU)\n\nContainer for parameters related to the MultiZone deficit model\n\nArguments\n\nme::Float: parameter controlling general wake expansion. Default value is 0.065\nke::Array{Float}(3): parameters controlling the wake expansion of each zone respectively. Default values are [-0.5 0.22 1.0].\nMU::Array{Float}(3): parameters controlling the wake deficit decay of each zone respectively. Default values are [0.5 1.0 5.5].\naU::Float: parameter impacting the wake deficit decay for a constant wake deflection. Default value is 5.0.\nbU::Float: parameter changing the wake deficit decay under yawed conditions. Default value is 1.66.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.MultizoneDeflection","page":"Reference","title":"FLOWFarm.MultizoneDeflection","text":"MultizoneDeflection(horizontal_spread_rate)\n\nContainer for parameters related to the Jiminez deflection model\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\nad::Float:Helps define the horizontal deflection of the wake at 0 deg yaw\nbd::Float:Helps define the horizontal deflection of the wake due to downwind distance at 0 deg yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.NoYawDeflection","page":"Reference","title":"FLOWFarm.NoYawDeflection","text":"NoYawDeflection()\n\nAllows for bypassing deflection calculations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerLawWindShear","page":"Reference","title":"FLOWFarm.PowerLawWindShear","text":"PowerLawWindShear(shear_exponent, ground_height)\n\nProvides shear exponent and ground height to define wind shear curve. Ground height may be tuned because the power law does not always hold near the ground.\n\nArguments\n\nshear_exponent::Float: defines trajectory of wind shear\nground_height::Float: height of the ground (typically zero)\nshear_order::Bool: when shear should be calculated. Can be \"first\", \"last\", or \"none\"\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelConstantCp","page":"Reference","title":"FLOWFarm.PowerModelConstantCp","text":"PowerModelConstantCp(cp)\n\nModels will assume a constant cp value as provided\n\nArguments\n\ncp::Float: constant power coefficient value\n'pp::TI': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelCpPoints","page":"Reference","title":"FLOWFarm.PowerModelCpPoints","text":"PowerModelCpPoints(vel_points, cp_points)\n\nModels will use adjust cp based on cp curve using linear interpolation of provided points\n\nArguments\n\nvel_points::Array{N,Float}: wind speed values in m/s\ncp_points::Array{N,Float}: power coefficient values corresponding to the provided speeds\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelPowerCurveCubic","page":"Reference","title":"FLOWFarm.PowerModelPowerCurveCubic","text":"PowerModelPowerCurveCubic()\n\nPower will be calculated based on turbine specifications assuming a cubic power curve. Note that this method is inherently incorrect and should only be used for theoretical purposes  or after careful validation.\n\nArguments\n\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelPowerPoints","page":"Reference","title":"FLOWFarm.PowerModelPowerPoints","text":"PowerModelPowerPoints(vel_points, cp_points)\n\nModels will use adjust wind turbine power based on power curve using linear interpolation of  provided points\n\nArguments\n\nvel_points::Array{N,Float}: wind speed values in m/s\npower_points::Array{N,Float}: power values corresponding to the provided speeds\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.ThrustModelConstantCt","page":"Reference","title":"FLOWFarm.ThrustModelConstantCt","text":"ThrustModelConstantCt(ct::Float)\n\nStores a constant ct value for wake calculations\n\nArguments\n\nct::Float: a constant ct value for computation\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.ThrustModelCtPoints","page":"Reference","title":"FLOWFarm.ThrustModelCtPoints","text":"ThrustModelCtPoints(vel_points, ct_points)\n\nStores the thrust coefficient curve in terms of corresponding velocity and thrust coefficient points. ct and velocity points should be in the same order and ordered from lowest wind speed to highest wind speed.\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine\nthrust_model::ThrustModelCtPoints: Struct containing ct and velocity points for ct curve\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.WindFarm","page":"Reference","title":"FLOWFarm.WindFarm","text":"WindFarm(windfarm, windresource, windfarmstates)\n\nStruct defining a wind farm\n\nArguments\n\nturbine_x::Array{Float}(Nturbines): contains windturbine x coordinates in the global reference frame\nturbine_y::Array{Float}(Nturbines): contains windturbine y coordinates in the global reference frame\nturbine_z::Array{Float}(Nturbines): contains windturbine base/z coordinates in the global reference frame\nturbine_definition_ids::Array{Int}(Nturbines): contains integers for each wind turbine specifying its definition\nturbine_definitions::Array{AbstractTurbineDefinition}(Ntypes): contains structs defining each wind turbine definition (design) used in the farm\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.WindFarmModelSet","page":"Reference","title":"FLOWFarm.WindFarmModelSet","text":"WindFarmModelSet(wakedeficitmodel, wake_deflection_model, wake_combination_model, local_ti_model)\n\nContainer for objects defining models to use in wind farm calculations\n\nArguments\n\nwake_defiict_model::AbstractWakeDeficitModel: contains a struct defining the desired wake deficit model\nwake_deflection_model::AbstractWakeDeflectionModel: contains a struct defining the desired wake deflection model\nwake_combination_model::AbstractWakeCombinationModel: contains a struct defining the desired wake combination model\nlocal_ti_model::AbstractTurbulenceIntensityModel: contains a struct defining the desired turbulence intensity model\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.DiscreteCircum","page":"Reference","title":"FLOWFarm.DiscreteCircum","text":"PointsOnCircum(center_x, center_y, r, n = 100)\n\nGiven a circle center, radius, and number of discrete points, returns an array of discrete points along the circle's circumference\n\nArguments\n\ncenter_x::Float64 : cartesian x-coordinate for the center of the circle\ncenter_y::Float64 : cartesian y-coordinate for the center of the circle\nr::Float64 : distance from circle's center to the circumference points\nn::Float64 : defaults to 100, is the number of discrete evenly-spaced points       that will be returned along the circle's circumference\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.GaussianTI-NTuple{8, Any}","page":"Reference","title":"FLOWFarm.GaussianTI","text":"GaussianTI(loc,turbine_x, turbine_y, rotor_diameter, hub_height, turbine_ct, \n    sorted_turbine_index, ambient_ti; div_sigma=2.5, div_ti=1.2)\n\nCalculate local turbulence intensity based on \"On wake modeling, wind-farm gradients and AEP      predictions at the Anholt wind farm\" by Pena Diaz, Alfredo; Hansen, Kurt Schaldemose;      Ott, Søren; van der Laan, Paul ??\n\nArguments\n\nloc::Array{Float,3}: [x,y,z] location of point of interest in wind direction ref. frame\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction    reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction    reference frame\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the    global reference frame\nambient_ti::Float: ambient turbulence intensity\ndiv_sigma::Float: ?\ndiv_ti::Float: ?\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.VR_boundary-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.VR_boundary","text":"VR_boundary(bndry_x_clsd, bndry_y_clsd, start_dist, turb_spacing, num_turbs, bndry_seg_length)\n\nUses the Boundary portion of Boundary-Grid variable reduction method place turbines along a closed wind farm boundary and perturb their location with one (1) variable <startdist>.  NOTE: Use of this function assumes prior use of VRbounary_startup(), which ensures the number of turbines placed on the boundary doesn't violate any minimum spacing rules eiter along the boundary or around corners.\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nstart_dist::Float64: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed\nturb_spacing::Float64: the fixed distance along the boundary's edge between       adjacent turbines\n'numturbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VRbounary_startup() has already been       run so that the user won't attempt to place too many turbines.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.VR_boundary_startup-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.VR_boundary_startup","text":"VR_bounary_startup(bndry_x_clsd, bndry_y_clsd, start_dist, turb_min_spacing, num_turbs)\n\nDetermines if the requested number of turbines can be placed along the closed boundary with spacing and corner constraints. If the requested <num_turbs> is too many, places as many turbines as possible along the boundary, and returns the number of turbines not placed. NOTE: A shortcoming is that the smallest-angled corner limits the spacing of all turbines. in the worst case, a very thin boundary area would prevent any more than one turbine being placed on the boundary, though more would be optimal. Future work would check to make sure this corner (and the length of its adjacent sides) don't actually require limiting the minimum distance between turbines.\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nstart_dist::Float64: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed\nturb_min_spacing::Float64: the fixed distance along the boundary's edge between       adjacent turbines\n'numturbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VRbounary_startup() has already been       run so that the user won't attempt to place too many turbines.\n'bndryseglength::Array{Int}`: an array of the lengths between adjacent       boundary verticies, corresponding to how they appear in bndry_x and _y\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._ct_to_axial_ind_func-Tuple{Any}","page":"Reference","title":"FLOWFarm._ct_to_axial_ind_func","text":"_ct_to_axial_ind_func(ct)\n\nCalculate axial induction from the thrust coefficient. See Gebraad et. al. 2017  \"Maximization of the Annual Energy Production of Wind Power Plants by Optimization of  Layout and Yaw-Based Wake Control\"\n\nArguments\n\nct::Float: thrust coefficient\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_potential_core-NTuple{6, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_potential_core","text":"_gauss_yaw_potential_core(dt, yaw, ct, as, ti, bs)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the length of the near wake potential core.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_spread-NTuple{5, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_spread","text":"_gauss_yaw_spread(dt, k, dx, x0, yaw)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the standard deviation of the wake.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_spread_interpolated-NTuple{6, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_spread_interpolated","text":"_gauss_yaw_spread_interpolated(dt, k, dx, x0, yaw)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the standard deviation of the wake. with an interpolation on the near wake. \n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._niayifar_added_ti_function-NTuple{12, Any}","page":"Reference","title":"FLOWFarm._niayifar_added_ti_function","text":"_niayifar_added_ti_function(x, d_dst, d_ust, h_ust, h_dst, ct_ust, kstar_ust, delta_y, \n    ti_amb, ti_ust, ti_dst, ti_area_ratio_in; s=700.0)\n\nMain code for calculating the local turbulence intensity at a turbine using the method of     Niayifar and Porte Agel (2015, 2016).\n\nArguments\n\nx::Float: downstream distance from turbine to point of interest\nd_dst::Float: downstream turbine rotor diameter\nd_ust::Float: upstream turbine rotor diameter\nh_ust::Float: upstream turbine hub height\nh_dst::Float: downstream turbine hub height\nct_ust::Float: upstream turbine thrust coefficient\nkstar_ust::Float: upstream turbine wake expansion rate\ndelta_y::Float: cross wind separation from turbine to point of interest\nti_amb::Float: ambient turbulence intensity\nti_ust::Float: upstream turbine local turbulence intensity\nti_dst::Float: downstream turbine local turbulence intensity\nti_area_ratio_in::Float: current value of TI-area ratio for use in calculatin local TI\ns::Float: smooth max smootheness parameter\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._remove_out_of_bounds_points-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm._remove_out_of_bounds_points","text":"_remove_perimeter_points!(n; alpha=0.0)\n\nInternal function. Removes points outside or outside and on the border of the rotor-swept      area \n\nArguments\n\ny::AbstractArray: horizontal point locations\nz::AbstractArray: vertical point locations \nuse_perimeter_points::Bool: flag that determines whether or not to include points on the    boundary of the rotor-swept area\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.add_turbine!-Tuple{Any}","page":"Reference","title":"FLOWFarm.add_turbine!","text":"add_turbine!(ax; view=\"side\", hubdiameter=0.1, hubheight=0.9, radius=0.5, chord=0.1, \n    nacellewidth=0.3, nacelleheight=0.1, towerbottomdiam=0.1, towertopdiam=0.05, \n    overhang=0.05, s=5)\n\nConvenience function for adding wind turbines to plots.\n\nArguments\n\nax::PyCall.PyObject: pre-initialized axis from pyplot\nview::Number: determines which turbine view to use \"top\" or \"side\" (default)\nhubdiameter::Number: hub diameter in axis coordinate frame\nhubheight::Number: hub height in axis coordinate frame\nradius::Number: full rotor radius in axis coordinate frame\nchord::Number: maximum chord in axis coordinate frame\nnacellewidth::Number: nacelle width in axis coordinate frame\nnacelleheight::Number: nacelle height in axis coordinate frame\ntowerbottomdiam::Number: tower bottom diameter in axis coordinate frame\ntowertopdiam::Number: tower top diameter in axis coordinate frame\noverhang::Number: overhang (distance from blade attachment to tower bottom in x axis) in axis coordinate frame\ns::Number: scales overhang and tower location in x direction to work with condensed x axis as in long contour plots\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.adjust_for_wind_shear-Tuple{Any, Any, Any, Any, FLOWFarm.PowerLawWindShear}","page":"Reference","title":"FLOWFarm.adjust_for_wind_shear","text":"adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, model::PowerLawWindShear)\n\nUses provided velocity at a given height to estimate the velocity at a different height due to wind shear. Ground height may be tuned because the power law does not always hold near the ground.\n\nArguments\n\nlocz::Float: height of desired velocity\nreference_velocity::Float: known velocity at reference_height\nreference_height::Float: height of known velocity \nground_height::Float: height of the ground (typically zero)\nmodel::AbstractWindShearModel: wind shear model to use for calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.boundary_normals_calculator-Tuple{Any}","page":"Reference","title":"FLOWFarm.boundary_normals_calculator","text":"boundary_normals_calculator(boundary_vertices; nboundaries=1)\n\nOutputs the unit vectors perpendicular to each edge of each polygon in a set of polygons,  given the Cartesian coordinates for each polygon's vertices.\n\nArguments\n\nboundary_vertices::Array{Float,1} : ragged array of arrays containing all the boundary vertices of each polygon, counterclockwise\nnboundaries::Int : the number of boundaries in the set\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calcMinorAngle","page":"Reference","title":"FLOWFarm.calcMinorAngle","text":"calcMinorAngle(bndry_x, bndry_y, bndry_z=[0,0,0])\n\nGiven three points in space, calculates the magnitude of the non-reflex angle formed at the center point. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nbndry_z::Array{Float,1} : 1-D array of z-coordinates for the vertices       around a singlar closed boundary. Default to [0,0,0] for X-Y plane\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.calcSmallestAngle-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calcSmallestAngle","text":"calcSmallestAngle(bndry_x_clsd, bndry_y_clsd)\n\nGiven a 1-D closed array of boundary verticies (with first point repeated at the end) it determines the smallest non-reflex angle created by any three consecutive verticies along the boundary. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calc_moment_stress","page":"Reference","title":"FLOWFarm.calc_moment_stress","text":"calc_moment_stress(mx,my,dx,dy,Rcyl=1.771,tcyl=0.06)\n\nCalculates stresses from bending moments on a hollow cylinder\n\nArguments\n\nmx::Float: x moment\nmy::Float: y moment\ndx::Float: x distance to the location of interest\ndy::Float: y distance to the location of interest\n\nKeyword Arguments\n\nRcyl::Float: radius of the cylinder\ntcyl::Float: thickenss of the cylinder\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.calculate_aep-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_aep","text":"calculate_aep(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0], hours_per_year=365.25*24.0)\n\nCalculate wind farm AEP\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\npower_model::Array{): elements of array should be sub types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotor_sample_points_y::Array{TF,N}: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotor_sample_points_z::Array{TF,N}: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelConstantCt}","page":"Reference","title":"FLOWFarm.calculate_ct","text":"calculate_ct(model::ThrustModelConstantCt)\n\nCalculate the thrust coefficient for a wind turbine based on a pre-determined constant ct\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine (unused for const. ct)\nthrust_model::ThrustModelConstantCt: struct containing a constant ct value for computation\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelCtPoints}","page":"Reference","title":"FLOWFarm.calculate_ct","text":"calculate_ct(inflow_velocity, thrust_model::ThrustModelCtPoints)\n\nCalculate the thrust coefficient for a wind turbine based on a pre-determined ct curve\n    with linear interpolation.\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine\nthrust_model::ThrustModelCtPoints: Struct containing ct and velocity points for ct curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_flow_field-Tuple{Any, Any, Any, FLOWFarm.AbstractModelSet, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Reference","title":"FLOWFarm.calculate_flow_field","text":"calculateflowfield(xrange, yrange, zrange, modelset::AbstractModelSet, turbinex,      turbiney, turbinez, turbineyaw, turbinect, turbineai, rotordiameter, hubheight,      turbinelocalti, sortedturbineindex, wtvelocities, windresource; windfarmstate_id=1)\n\nGenerates a flow field for a given state and cross section\n\nArguments\n\nxrange::Range: range defining east-west locations to sample in global reference frame\nyrange::Range: range defining north-west locations to sample in global reference frame\nzrange::Range: range defining vertical locations to sample in global reference frame\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the global reference frame\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nturbine_ct::Array{TF,nTurbines}: thrust coefficient of each turbine for the given state\nturbine_ai::Array{TF,nTurbines}: turbine axial induction for the given state\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_local_ti::Array{TF,nTurbines}: turbine local turbulence intensity for    the given state\nsorted_turbine_index::Array{TF,nTurbines}: turbine north-south locations in the    global reference frame\nwtvelocities::Array{TF,nTurbines}: effective inflow wind speed for given state\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelMaxTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelMaxTI; turbine_id=1, tol=1E-6)\n\nReturns local turbulence intensity calculated using Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction    reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction    reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the    global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelMaxTI: contains a struct defining the desired turbulence intensity model, no local TI in this case\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelNoLocalTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelNoLocalTI; turbine_id=1, tol=1E-6)\n\nReturns ambient turbulence intesity value whenever local turbulence intensity is requestesd\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction    reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction    reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the    global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelNoLocalTI: contains a struct defining the desired turbulence intensity model, no local TI in this case\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelConstantCp}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, power_model)\n\nCalculate the power for a wind turbine based on standard theory for region 2 using a constant cp\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelConstantCp: Struct containing the cp value to be used in region 2\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelCpPoints}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculate the power for a wind turbine based on a cp curve with linear interpolation\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelCpPoints: Struct containing the velocity and cp values defining the cp curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerCurveCubic}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculates wind turbine power using a cubic estimation based on turbine specifications     as defined in https://github.com/byuflowlab/iea37-wflo-casestudies/blob/master/cs3-4/iea37-cs3-announcement.pdf\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelPowerCurveCubic: Empty struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerPoints}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculate the power for a wind turbine based on a pre-determined power curve with linear     interpolation\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelPowerPoints: Struct containing the velocity and power values   defining the power curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power_from_cp-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.calculate_power_from_cp","text":"calculate_power_from_cp(generator_efficiency, air_density, rotor_area, cp, wt_velocity)\n\nCalculate the power for a wind turbine based on standard theory for region 2\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\ncp::Float: Power coefficient of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_state_aeps-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_state_aeps","text":"calculate_state_aeps(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])\n\nCalculate AEP for each requested state respectively\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\npower_model::Array{nTurbines}: elemenst of array should be sub-types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_state_turbine_powers-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_state_turbine_powers","text":"calculate_state_turbine_powers(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])\n\nCalculate power for each turbine for all states respectively\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\npower_models::Array{nTurbines}: elemenst of array should be sub-types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_turbine_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractPowerModel, Any}","page":"Reference","title":"FLOWFarm.calculate_turbine_power","text":"calculate_turbine_power(generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, \nrated_power, rotor_diameter, wt_velocity, power_model::AbstractPowerModel, air_density)\n\nCalculate the power for all wind turbines. Dispaches to desired power model.\n\nArguments\n\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nrotor_diameter::Array{Float,nTurbines}\nwt_velocity::Array{Float,nTurbines}: turbine effective wind speeds for current state only\n`power_model::AbstractPowerModel)\nair_density::Float\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.circle_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.circle_boundary","text":"circle_boundary(center,radius,turbine_x,turbine_y)\n\ncalculate the distance from each turbine to a circular boundary. Negative means the turbine is inside the boundary\n\nArguments\n\ncenter::Float: circular boundary center [x,y]\nradius::Float: circulat boundary radius\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.closeBndryList-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.closeBndryList","text":"closeBndryList(bndryPts_x, bndryPts_y)\n\nAppends the 1st element to the end of the coordinate arrays if it is not already repeated. Note, this will only work on 1-D arrays. For an array of 1-D arrays, use closeBndryLists(bndryPts_x, bndryPts_y) (note the plural, not singular 'Lists' in the function title)\n\nArguments\n\nbndryPts_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndryPts_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.closeBndryLists-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.closeBndryLists","text":"closeBndryLists(bndryPts_x, bndryPts_y)\n\nAppends the 1st element to the end of each array for a closed boundary. Note, this will not function properly if there is only one region. For only one region, use closeBndryList(bndryPts_x, bndryPts_y) (note the singular, not plural 'List' in the function title)\n\nArguments\n\nbndryPts_x::Array{Float,1} : N-D array of x-coordinates for the vertices       around N-many closed boundaries\nbndryPts_y::Array{Float,1} : N-D array of y-coordinates for the vertices       around N-many closed boundaries\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.convex_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.convex_boundary","text":"convex_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)\n\ncalculate the distance from each turbine to a possibly non-circular, but convex boundary. Negative means the turbine is inside the boundary\n\nArguments\n\nboundary_vertices::Array{Float,2}: vertices of the convex hull CCW in order s.t.       boundaryVertices[i] -> first point of face for unit_normals[i]\nboundary_normals::Array{Float,2}: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.coordDist-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.coordDist","text":"coordDist(x1, y1, x2, y2)\n\nGiven a two points (x1, y1) and (x2, y2), returns the euclidean distance between them\n\nArguments\n\nx1::Float64 : x-coord of the first point\ny1::Float64 : y-coord of the first point\nx2::Float64 : x-coord of the second point\ny2::Float64 : y-coord of the second point\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.distributed_velocity_op","page":"Reference","title":"FLOWFarm.distributed_velocity_op","text":"distributed_velocity_op(V, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)\n\nReturn the operating points along the blade considering varied inflow along the blade.\n\nArguments\n\nV::Array{Float}: velocity inflow at each r\nOmega::Float: rotor rotational speed\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\ntilt::Float: rotor tilt angle\nazimuth::Float: blade azimuth angle\nrho::Float: air density\n\nKeyword Arguments\n\nmu::Float: air viscocity (can usually use the default)\nasound::Float: speed of sound (can usually use the default)\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.find_upstream_turbines-Tuple{Any, Any, AbstractArray, Any}","page":"Reference","title":"FLOWFarm.find_upstream_turbines","text":"find_upstream_turbines(turbinex, turbiney, winddirection, diameter; inverse=false)\n\nA convenience function to quickly find either which turbines are waked, or those that are  not. \n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame \nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirection::Real or winddirection::AbstractArray: wind direction in radians in meteorological coordinates (0 rad. = from North)\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.find_xyz_simple-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.find_xyz_simple","text":"find_xyz_simple(x_hub,y_hub,z_hub,r,yaw,azimuth)\n\nFind the xyz locations of points along a blade given it's location and azimuth angle. Currently doesn't consider precone or tilt.\n\nArguments\n\nx_hub::Float: x location of hub\ny_hub::Float: y location of hub\nz_hub::Float: z location of hub (hub height if no topology)\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\nazimuth::Float: blade azimuth angle\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.getNextFileName","page":"Reference","title":"FLOWFarm.getNextFileName","text":"getNextFileName(directory, file_name, file_type)\n\nChecks if a file of the given directory and name exists. If not, increments to the next index so as not to overwrite previously written files. If it reaches the max number of overwrites, it will default to <directory/filename.filetype> To default to this, set <max_check=0> in function call.\n\nArguments\n\ndirectory::String: path/to/write/file/at/\nfile_name::String: Whatever the name of the file desired\nfile_type::String: ex \"yaml\", \"txt\", \"csv\", etc...\nmax_check::Int: the maximum number of files to check\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.getPerimeterLength-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.getPerimeterLength","text":"getPerimeterLength(bndry_x_clsd, bndry_y_clsd)\n\nGiven a 1-D closed array of boundary verticies (with first point repeated at the end) returns the length along the perimeter. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.getUpDwnYvals-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.getUpDwnYvals","text":"getUpDwnYvals(turbine_x, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\nSupplements FLOWFarm's splinedboundary() function by calculating (for a given x location) the maximum and minimum y-value permitted to remain \"inside\" the boundary. If turbinex is located left of the boundary's leftmost vertex or right of the boundary's rightmost vertex, it return's that corresponding vertex's y-value as the max and min, as default. Returns two values, the minimum and maximum interior y-values withing a boundary for the given turbine_x value. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: x-value of the turbine being examined\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_boundary_yaml-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_boundary_yaml","text":"get_boundary_yaml(filename)\n\nReturns the boundaries of a wind farm as defined in a yaml file in the format used in FLOWFarm. Returns N by 2 array for single region farm and an array of  N by 2 arrays for multiple regions. Returned regions are sorted alphabetically by the keys provided in the yaml file.\n\nArguments\n\nfile_name::String: relative/path/to/file\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_moments-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.get_moments","text":"get_moments(out,Rhub,Rtip,r,az,precone,tilt)\n\nTrapezoidal integration to find the blade root bending moment using the loads distribution\n\nArguments\n\n`out::CCBlade dict: output from running CCBlade solve\nRhub::Float: radius of the rotor hub\nRtip::Float: radius of the blade tip\nr::Array{Float}: radial locations of interest\naz::Float: blade azimuth angle\nprecone::Float: rotor precone angle\ntilt::Float: rotor tilt angle\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_peaks-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_peaks","text":"get_peaks(array)\n\nget the turning point values of a signal\n\nArguments\n\narray::Array{Float}: the signal to find the turning points, or peaks\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_peaks_indices-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_peaks_indices","text":"get_peaks_indices(array)\n\nreturn the indices of the signal peaks\n\nArguments\n\narray::Array{Float}: the signal to find the turning points, or peaks\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_turb_atrbt_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_turb_atrbt_YAML","text":"get_turb_atrbt_YAML(file_name)\n\nread in turbine attributes from .yaml\n\nArguments\n\nfile_name::String: path/to/attribute/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_turb_loc_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_turb_loc_YAML","text":"get_turb_loc_YAML(file_name)\n\nread in turbine locations and related problem file names from .yaml\n\nArguments\n\nfile_name::String: path/and/name/of/location/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_wind_rose_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_wind_rose_YAML","text":"get_wind_rose_YAML(file_name)\n\nread in wind resource information from .yaml\n\nArguments\n\nfile_name::String: path/to/wind/resource/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.grid_points-Tuple{Any}","page":"Reference","title":"FLOWFarm.grid_points","text":"grid_points(n)\n\nGenerates points in a grid. If n is not a perfect square, then the nearest square root will  be used for the side length of the grid.\n\nArguments\n\nn::Float: number of points to generate\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.hermite_spline-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.hermite_spline","text":"hermite_spline(x, x0, x1, y0, dy0, y1, dy1)\n\nProduces the y and (optionally) dy values for a hermite cubic spline interpolating between two end points with known slopes\n\nArguments\n\nx::Float: x position of output y\nx0::Float: x position of upwind endpoint of spline\nx1::Float: x position of downwind endpoint of spline\ny0::Float: y position of upwind endpoint of spline\ndy0::Float: slope at upwind endpoint of spline\ny1::Float: y position of downwind endpoint of spline\ndy1::Float: slope at downwind endpoint of spline\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.iea37cs4BndryVRIntPM-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.iea37cs4BndryVRIntPM","text":"iea37cs4BndryVRIntPM(bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbine_x, turbine_y, turb_diam, turb_min_space, num_turbs_to_place)\n\nUses the Variable reduction method for placing boundary turbines, and the Partition Method (from splined_boundary()) for random interior points, maintaining proper spacing from all previously placed turbines.\n\nArguments\n\nbndry_x_clsd::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y_clsd::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nbndry_corner_indcies::Float64: The indicies within <bndryxclsd> and       <bndryyclsd> which denote the \"corners\" adjacent turbines\n'turbminspace::Float64`: For proximity knowledge, the minimum spacing       required between any two turbines\n'numbndryturbs::Float64`: The number of turbines desired to be placed along       the boundary. If too many are selected (due to spacing condtraints), the       remaining will be placed in the interior\n'numtotturbs::Float64`: The number of total turbines to be placed both on       the boundary and in the interior\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.latlong_to_xy-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.latlong_to_xy","text":"latlong_to_xy(latitude, longitude, utm_zone; isnorth=true, units=\"m\")\n\nConverts arrays of points from latitude and longitude to x and y in meters in a local coordinate frame based on the point with the lowest magnitude latitude,\n\nArguments\n\nlatitude::Array{Float,N}\nlongitude::Array{Float,N}\nisnorth::Float: specifies if the point is in the northern hemisphere (defaul: true)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.met2cart-Tuple{Number}","page":"Reference","title":"FLOWFarm.met2cart","text":"met2cart(angle_met)\n\nConvert from meteorological polar system (CW, 0 rad.=N, wind from) to cartesian polar system  (CCW, 0 rad.=E, wind to).\n\nArguments\n\nangle_met::Number: an angle in radians in a meteorological coordinate system\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.multiple_components_op","page":"Reference","title":"FLOWFarm.multiple_components_op","text":"multiple_components_op(U, V, W, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)\n\nReturn the operating points along the blade considering all the inflow velocity components.\n\nArguments\n\nU::Array{Float}: u velocity component of the inflow at each r\nV::Array{Float}: v velocity component of the inflow at each r\nW::Array{Float}: w velocity component of the inflow at each r\nOmega::Float: rotor rotational speed\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\ntilt::Float: rotor tilt angle\nazimuth::Float: blade azimuth angle\nrho::Float: air density\n\nKeyword Arguments\n\nmu::Float: air viscocity (can usually use the default)\nasound::Float: speed of sound (can usually use the default)\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.nansafenorm-Tuple{Vector{T} where T}","page":"Reference","title":"FLOWFarm.nansafenorm","text":"nansafenorm(v)\n\nCalculate the norm of a vector, but if the sum of the squares is less than the given tolerance  then use the line y = a(sqrt(eps())/eps()) so that the derivative is well defined.\n\nArguments\n\nv::Vector{}: takes the norm of this vector, but avoids NaN by using a linear    approximation of sqrt near 0.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.nansafesqrt-Tuple{Number}","page":"Reference","title":"FLOWFarm.nansafesqrt","text":"nansafesqrt(a)\n\nCalculate the square root of a number, but if the number is less than the given tolerance  then use the line y = a(sqrt(eps())/eps()) so that the derivative is well defined.\n\nArguments\n\na::Number: takes the square root of this value, or approximates it with a line for a < eps()\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotboundary!-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.plotboundary!","text":"plotboundary!(ax, boundary_vertices; color=\"k\", linestyle=\"-\", nboundaries=1)\n\nConvenience function for plotting wind farm boundaries\n\nArguments\n\n`ax\nboundary_vertices::Array{Float,1}(nvertices): an nx2 array of boundary vertices for polygon or [[centerx, centery], radius] for circle boundary\ncolor::=String: sets color for turbine markers\nlinestyle::String: sets the line style for the boundary\nnboundaries::Int: number of discrete boundary regions\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotlayout!-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.plotlayout!","text":"plotlayout!(ax, turbinex, turbiney, rotordiameter; aspect=\"equal\", xlim=[], ylim=[], fill=false, color=\"k\", markeralpha=1, title=\"\")\n\nConvenience function for plotting wind farm layouts\n\nArguments\n\n`ax\nturbinex::Array{Float,1}(nturbines): an array x coordinates of wind turbine locations\nturbiney::Array{Float,1}(nturbines): an array y coordinates of wind turbine locations\nrotordiameter::Array{Float,1}(nturbines): an array rotor diameters of wind turbines\naspect::String: set plot aspect ratio, default=\"equal\"\nxlim::Array: limits in x coordinate. \"[]\" results in limits being automatically defined\nylim::Array: limits in y coordinate. \"[]\" results in limits being automatically defined\nfill::Bool: determines whether turbine circle markers are filled or not\ncolor::=String: sets color for turbine markers\nmarkeralpha::Int: determines tranparancy of turbine markers\nitle::String: optional title to include on the plot\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotrotorsamplepoints!-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.plotrotorsamplepoints!","text":"plotrotorsamplepoints!(ax, y, z; rotordiameter=2.0, aspect=\"equal\", ylim=[], zlim=[], fill=false, color=\"k\", markeralpha=1, title=\"\")\n\nConvenience function for plotting where points are being sampled on the wind turbine rotor\n\nArguments\n\n`ax\ny::Array{Float,1}(nturbines): an array x coordinates of wind turbine locations\nz::Array{Float,1}(nturbines): an array y coordinates of wind turbine locations\nrotordiameter::Number: rotor diameter of wind turbine\naspect::String: set plot aspect ratio, default=\"equal\"\nylim::Array: limits in y coordinate. \"[]\" results in limits being automatically defined\nzlim::Array: limits in z coordinate. \"[]\" results in limits being automatically defined\nfill::Bool: determines whether turbine circle markers are filled or not\ncolor::=String: sets color for turbine markers\nmarkeralpha::Int: determines tranparancy of turbine markers between 0 (transparent) and 1 (opaque)\nitle::String: optional title to include on the plot\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotsingleboundary!-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.plotsingleboundary!","text":"plotsingleboundary!(ax, boundary_vertices; color=\"k\", linestyle=\"-')\n\nConvenience function for plotting wind farm boundaries\n\nArguments\n\n`ax\nboundary_vertices::Array{Float,1}(nvertices): an nx2 array of boundary vertices for polygon or [[centerx, centery], radius] for circle boundary\ncolor::=String: sets color for turbine markers\nlinestyle::String: sets the line style for the boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotwindfarm!-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.plotwindfarm!","text":"plotwindfarm!(ax, boundary_vertices, turbinex, turbiney, rotordiameter; nboundaries=1, aspect=\"equal\", xlim=[], ylim=[], fill=false, color=\"k\", markeralpha=1, title=\"\")\n\nConvenience function for plotting wind farms\n\nArguments\n\n`ax\nboundary_vertices::Array{Float,1}(nvertices): an nx2 array of boundary vertices\nturbinex::Array{Float,1}(nturbines): an array x coordinates of wind turbine locations\nturbiney::Array{Float,1}(nturbines): an array y coordinates of wind turbine locations\nrotordiameter::Array{Float,1}(nturbines): an array rotor diameters of wind turbines\nnboundaries::Int: number of discrete boundary regions\naspect::String: set plot aspect ratio, default=\"equal\"\nxlim::Array: limits in x coordinate. \"[]\" results in limits being automatically defined\nylim::Array: limits in y coordinate. \"[]\" results in limits being automatically defined\nfill::Bool: determines whether turbine circle markers are filled or not\ncolor::=String: sets color for turbine markers\nmarkeralpha::Int: determines tranparancy of turbine markers\ntitle::String: optional title to include on the plot\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotwindresource!-Tuple{FLOWFarm.DiscretizedWindResource}","page":"Reference","title":"FLOWFarm.plotwindresource!","text":"plotwindresource!(ax::Array, windresource::ff.DiscretizedWindResource; roundingdigits=[1,3], fill=false, alpha=0.5, colors=[\"b\", \"b\"], fontsize=8, edgecolor=nothing, rlabel_position=-45)\n\nConvenience function for visualizing the wind speed and wind frequency roses\n\nArguments\n\nax::Array: pre-initialized single dimension array of axes from pyplot with length at least 2\nwindresource::ff.DiscretizedWindResource: wind rose information\nroundingdigits::Array{Int, 1}: how many significant digits to round to on each axis in ax\nfill::Bool: determines whether bars are filled or not\nalpha::Number: tranparancy of bars between 0 (transparent) and 1 (opaque)\ncolors::=Array{String, 1}: sets color for turbine markers\nfontsize::Int: font size of text on figures\nedgecolor: color of edges of each bar in polar chart, nothing means no color\nrlabel_position:Number: Angle at which to draw the radial axes\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.plotwindrose!-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.plotwindrose!","text":"plotwindrose!(ax, d, f; roundingdigit=1, color=\"C0\",alpha=0.5,fontsize=8,\ndticks=(0,pi/4,pi/2,3*pi/4,pi,5*pi/4,3*pi/2,7*pi/4),\ndlabels=(\"E\",\"NE\",\"N\",\"NW\",\"W\",\"SW\",\"S\",\"SE\"),\nfticks=nothing, flabels=nothing, normalize=false, edgecolor=nothing, units=\"\",\nrlabel_position=-45)\n\nConvenience function for creating a windrose from any polar data\n\nArguments\n\nax::PyCall.PyObject: pre-initialized axis from pyplot\nd::Vector: wind rose directions\nf::Vector: wind rose radial variable\nroundingdigit::Int: how many significant digits to round to\nfontsize::Int: font size of text on figures\ndticks::Tuple: contains angular tick locations\ndlabels::Tuple: contains angular tick labels\nfticks::Tuple: contains radial tick locations\nflabels::Tuple: contains radial tick labels\nnormalize::Bool: choose whether or not to normalize by the sum of f\nunits::String: Units to append to flabels\nrlabel_position:Number: Angle at which to draw the radial axis\nplotcommand::String: Type of plot. Can be [\"bar\", \"plot\"]\nkwargs::Tuple: tuple containing key word arguments to plotcommand in the form (key => \"value\")\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.point_velocity-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.point_velocity","text":"point_velocity(loc, turbine_x, turbine_y, turbine_z, turbine_yaw, turbine_ct, turbine_ai,\nrotor_diameter, hub_height, turbine_local_ti, sorted_turbine_index, wtvelocities,\nwind_resource, model_set::AbstractModelSet;\nwind_farm_state_id=1, downwind_turbine_id=0)\n\nCalculates the wind speed at a given point for a given state\n\nArguments\n\nloc::Array{TF,3}: Location of interest\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the state    reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the state    reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the state reference frame\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nturbine_ct::Array{TF,nTurbines}: turbine thrust coefficients for the given state\nturbine_ai::Array{TF,nTurbines}: turbine axial induction for the given state\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_local_ti::Array{TF,nTurbines}: turbine local turbulence intensity for    the given state\nsorted_turbine_index::Array{TF,nTurbines}: array containing indices of wind turbines    from most upwind to most downwind turbine in the given state\nwtvelocities::Array{TF,nTurbines}: effective inflow wind speed for given state\nwind_resource::DiscretizedWindResource: contains wind resource discreption (directions,   speeds, frequencies, etc)\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\ndownwind_turbine_id::Int: index of wind turbine of interest (if any). If not a point for   calculating effective wind speed of a turbine, then provide 0 (default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.pointinpolygon","page":"Reference","title":"FLOWFarm.pointinpolygon","text":"pointinpolygon(point, vertices, normals=nothing; s=700, method=\"raycasting\", shift=1E-10, return_distance=true)\n\nGiven a polygon determined by a set of vertices, determine the signed distance from the point  to the polygon. \n\nReturns the negative (-) distance if the point is inside or on the polygon, positive (+)  otherwise. If return_distance is set to false, then returns -1 if in polygon or on the  boundary, and 1 otherwise.\n\nArguments\n\npoint::Vector{Number}(2): point of interest\nvertices::Vector{Matrix{Number}(2): vertices of polygon\nnormals::Vector{Matrix{Number}(2): if not provided, they will be calculated\ns::Number: smoothing factor for ksmax function (smoothmax)\nmethod::String: currently only raycasting is available\nshift::Float: how far to shift point if it lies on an edge or vertex\nreturn_distance::Bool: if true, return distance. if false, return -1 if in polygon or on the boundary, and 1 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.pointonline-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.pointonline","text":"pointonline(p, v1, v2; tol=1E-6)\n\nGiven a line determined two points (v1 and v2) determine if the point (p) lies on the line between those points. \n\nReturns true if the point lies on the line (within the given tolerance), false otherwise.\n\nArguments\n\np::Vector{Number}(2): point of interest\nv1::Vector{Number}(2): first vertex of the line\nv2::Vector{Number}(2): second vertex of the line\ntol::Number: how close the cumulative distance from v1 to p to v2 must be to the distance from v1 to v2 to count as being co-linear\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.print_layout_in_cartesian_frame_excel-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.print_layout_in_cartesian_frame_excel","text":"print_state_layouts_in_cartesian_frame(turbinex, turbiney, winddirections)\n\nGiven a wind farm layout in the global reference frame, print the layout rotated to the  cartesian frame with wind to the positive x axis (right) for all wind directions.\n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame \nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirections::Array{T,1}: all wind directions in radians in meteorological coordinates (0 rad. = from North)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rainflow","page":"Reference","title":"FLOWFarm.rainflow","text":"rainflow(array_ext,uc_mult=0.5)\n\nRainflow counting of a signal's turning points\n\nArguments\n\n    array_ext (numpy.ndarray): array of turning points\n\nKeyword Arguments\n\n    uc_mult (float): partial-load scaling [opt, default=0.5]\n\nReturns\n\n    array_out (numpy.ndarray): (3 x n_cycle) array of rainflow values:\n                                1) load range\n                                2) range mean\n                                3) cycle count\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.ray_casting_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.ray_casting_boundary","text":"ray_casting_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)\n\nCalculate the distance from each turbine to the nearest point on the boundary using  the ray-casting algorithm. Negative means the turbine is inside the boundary.\n\nArguments\n\nboundary_vertices::Array{Float,2}: vertices of the boundary CCW in order s.t.       boundaryVertices[i] -> first point of face for unit_normals[i]\nboundary_normals::Array{Float,2}: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\ndiscrete::Bool: if true, indicates the boundary is made of multiple discrete regions\ns::Number: smoothing factor for smooth max (ksmax)\ntol::Float: how close points have to be to vertex or face before they will be shifted slightly to avoid a discontinuity\nreturn_region::bool: if true, return a vector specifying which region each turbine is in\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rediscretize_windrose-Tuple{FLOWFarm.DiscretizedWindResource, Any}","page":"Reference","title":"FLOWFarm.rediscretize_windrose","text":"rediscretize_windrose(windrosein::DiscretizedWindResource, ndirectionbins, nspeedbins)\n\nFunction for re-interpreting a wind rose into a desired number of bins. Returns the new\nwind rose. Currently only works for windroses with a single speed in each direction.\n\nArguments\n\nwindrosein::DiscretizedWindResource: original wind rose\nndirectionbins::Integer: number of direction bins for the new wind rose\nstart::Float: direction for first bin in radians\naveragespeed::Bool: set whether or not to return the average wind speed as the speed for all bins\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rotate_to_wind_direction-Tuple{Any, Any, Number}","page":"Reference","title":"FLOWFarm.rotate_to_wind_direction","text":"rotate_to_wind_direction(xlocs, ylocs, wind_direction_met)\n\nRotates wind farm coordinates to be in wind direction reference where wind direction is to the positive x.\n\nArguments\n\nxlocs::Array: contains turbine east-west locations in the global reference frame\nylocs::Array: contains turbine north-south locations in the global reference frame\nwind_direction_met::Array: contains wind direction in radians in meteorological standard    system (N=0 rad, proceeds CW, wind from direction given)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rotor_sample_points","page":"Reference","title":"FLOWFarm.rotor_sample_points","text":"rotor_sample_points(nsamplepoints=1)\n\nInitializes the sampling locations in the rotor-swept-area. Returns values such that zero is at the turbine hub location and 1 is at the tip of the blades. If a single sample is requested, it will be at the hub location. Otherwise, the points will be located using the sunflower packcing algorithm.\n\nArguments\n\nnsamplepoints::Int: controlls how many sample points to generate\nalpha::Float: Controls smoothness of the sunflower algorithm boundary. alpha=0 is the standard \"jagged edge\" sunflower algoirthm and   alpha=1 results in a smooth boundary.\npradius::Float: the percent of the rotor radius to use in generating initial point grid \nuse_perimeter_points: whether or not to include point exactly on the perimeter of the    rotor swept area \n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.round_farm_random_start-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.round_farm_random_start","text":"round_farm_random_start(rotor_diameter, center, radius; min_spacing=2., min_spacing_random=3., method=\"individual\")\n\nGenerates starting locations for multi-start optimization approaches when the farm boundary is round.\n\nArguments\n\nrotor_diameter::Number: wind turbine diameter \ncenter::Number: wind farm center\nradius::Number: wind farm radius\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.smooth_max-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.smooth_max","text":"smooth_max_ndim(x; s=100.0)\n\nCalculate the smooth-max (a.k.a. softmax or LogSumExponential) of the elements in x.\n\nBased on John D. Cook's writings at  (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\n\nArguments\n\nx::Float: first value for comparison\ny::Float: second value for comparison\ns::Float : controls the level of smoothing used in the smooth max\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.smooth_max-Tuple{Any}","page":"Reference","title":"FLOWFarm.smooth_max","text":"smooth_max(x; s=10.0)\n\nCalculate the smoothmax (a.k.a. softmax or LogSumExponential) of the elements in x.\n\nBased on John D. Cook's writings at  (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\n\nAnd based on article in FeedlyBlog (3) https://blog.feedly.com/tricks-of-the-trade-logsumexp/\n\nArguments\n\nx::Array{Float,1} : vector with all the input values\ns::Float : controls the level of smoothing used in the smooth max\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.splined_boundary-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.splined_boundary","text":"splined_boundary(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\ncalculate the distance from each turbine to a closed boundary made up of zero or more reflex angles (concavities). Boundary will have three or four user-selected \"corners\", such that the \"sides\" between corners (that will be splined) are injective functions (meaning that for every x-coord, there exists only one corresponding y-coord). Returns four values for every turbine, corresponding to the distance from the turb to the upper, lower, left, and right splined \"sides\". A negative return value means the turb is inside the boundary for that \"side\". Returns a single array of {Float64} of length {length(turbine_x) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.splined_boundary_discreet_regions-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.splined_boundary_discreet_regions","text":"splined_boundary_discreet_regions(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbs_per_region)\n\nUses FLOWFarm's splinedboundary() function to calculate the turbine-boundary constraints for one or more discreet regions, with pre-allocated turbines for each region. Returns four values for every turbine, corresponding to the distance from each turb to the upper, lower, left, and right splined \"sides\" for the region to which it was allocated. A negative return value means the turb is outside the \"side\" of boundary for which it has been allocated. Returns a single array of {Float64} of length {length(turbinex) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n'turbsperregion::Array{Int}`: An array of length equivalent to the number of       discrete boundary regions, with each element denoting howmany turbines       are apportioned to the corresponding region. sum(turbsperregion) must       be equivalent to the total number of turbines in the windfarm\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.sunflower_points-Tuple{Any}","page":"Reference","title":"FLOWFarm.sunflower_points","text":"sunflower_points(n; alpha=0.0)\n\nGenerates points in a circle of radius=1 using the sunflower packing algorithm. \n\nArguments\n\nn::Float: number of points to generate\nalpha::Float: Controls the smoothness of the boundary. alpha=0 is the standard \"jagged edge\" sunflower algoirthm and   alpha=1 results in a smooth boundary.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_powers_one_direction-NTuple{10, Any}","page":"Reference","title":"FLOWFarm.turbine_powers_one_direction","text":"turbine_powers_one_direction((generator_efficiency, cut_in_speed, cut_out_speed, \n    rated_speed, rated_power, rotor_diameter, turbine_inflow_velcities, air_density, power_model::AbstractPowerModel)\n\nCalculate the power for all wind turbines for a given state\n\nArguments\n\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nrotor_diameter::Array{Float,nTurbines}\nturbine_inflow_velcities::Array{Float,nTurbines}: for current state only\nair_density::Float\npower_models::Array{nturbines}) elements of array should be be of sub-types or AbstractPowerModel\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_spacing-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.turbine_spacing","text":"turbine_spacing(turbine_x,turbine_y)\n\nCalculate the distance between turbines in a wind farm. There is an infinite gradient of this function if two points are exactly the same. This can be avoided by returning the square of the turbine spacing rather than the actual distance, but it makes the gradients scale much more poorly. Because it is very vanishingly rare to have turbines exactly in the same location, this function leaves the square root in the calculations.\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_velocities_one_direction-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.turbine_velocities_one_direction","text":"point_velocity(turbine_x, turbine_y, turbine_z, rotor_diameter, hub_height, turbine_yaw,\nsorted_turbine_index, ct_model, rotor_sample_points_y, rotor_sample_points_z, wind_resource,\nmodel_set::AbstractModelSet; wind_farm_state_id=1)\n\nCalculates the wind speed at a given point for a given state\n\nArguments\n\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the state    reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the state    reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the state reference frame\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nsorted_turbine_index::Array{TF,nTurbines}: turbine sorted order upstream to downstream    for given state\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_count_iec-Tuple{Any, Any, Real, Any}","page":"Reference","title":"FLOWFarm.wake_count_iec","text":"wake_count_iec(turbinex, turbiney, winddirection, diameter; return_turbines=true)\n\nAdapted from NREL's floris\n\nFinds the number of turbines waking each turbine for the given\nwind direction. Waked directions are determined using the formula\nin Figure A.1 in Annex A of the IEC 61400-12-1:2017 standard.\n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame \nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirection::Float: wind direction in radians in meteorological coordinates (0 rad. = from North)\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussOriginal}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussOriginal)\n\nComputes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"A new analytical model for wind-turbine wakes\" (2014)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussOriginal: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussSimple}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussSimple)\n\nComputes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"A new analytical model for wind-turbine wakes\" (2014)     as modified for IEA Task 37 Case Studies 3 and 4\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussSimple: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpread}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYawVariableSpread)\n\nComputes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" (2016) The spread rate is adjusted based on local turbulence intensity as in Niayifar and Porte-Agel 2016\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussYawVariableSpread: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYaw}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYaw)\n\nComputes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" (2016)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussYaw: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenCosine}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenCosine)\n\nComputes the wake deficit according to the original Jensen cosine wake model, from the paper: \"A Note on Wind Generator Interaction\" by N.O. Jensen (1983)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::JensenCosine: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenTopHat}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenTopHat)\n\nComputes the wake deficit according to the original Jensen top hat wake model, from the paper: \"A Note on Wind Generator Interaction\" by N.O. Jensen (1983)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::JensenTopHat: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.MultiZone}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::MultiZone)\n\nComputes the wake deficit at a given location using the original MultiZone \"FLORIS\" wake model, from the paper: \"Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study\" by Gebraad et al. (2014)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::MultiZone: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake\n\nBased on:\n[1] Bastankhah and Porte-Agel 2016 \"Experimental and theoretical study of\nwind turbine wakes in yawed conditions\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpreadDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(oc, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawVariableSpreadDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake. Varies based on local turbulence intensity.\n\nBased on:\n[1] Bastankhah and Porte-Agel 2016 \"Experimental and theoretical study of\nwind turbine wakes in yawed conditions\"\n[2] Niayifar and Porte-Agel 2016 \"Analytical Modeling of Wind Farms:\nA New Approach for Power Prediction\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JiminezYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::JiminezYawDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake\n\nBased on:\n[1] Jiminez 2010 \"Wake defl ection of a wind turbine in yaw\"\n[2] Gebraad 2014 \"Wind plant optimization by yaw control using a parametric wake model\"\nthis version ignores the corrections made to the yaw model for rotor rotation as described in [2] and\n[3] Thomas 2017 \"Improving the FLORIS wind plant model for compatibility with gradient-based optimization\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.NoYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::NoYawDeflection, windfarmstate::SingleWindFarmState)\n\nBypasses yaw deflection calculations.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.write_turb_loc_YAML-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.write_turb_loc_YAML","text":"write_turb_loc_YAML(file_name, data)\n\nwrite turbine locations and related information to .yaml\n\nArguments\n\nfile_name::String: path/and/name/of/location/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Tutorial/#Tutorial","page":"Quick Start","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"This tutorial covers the basics of FlowFARM. For more specifics refer to the How-to guide.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"This tutorial discusses how to do the following with FLOWFarm:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(1) setting up a problem description\n(2) setting up an analysis model set\n(3) running analyses\n(4) setting up and running an optimization\n(5) calculating and visualizing a flow field","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Details for setting up an optimization will depend heavily on the optimization package you are using, your objective, and your design variables. Optimization examples using various packages are provided in the example scripts located in the test  directory.","category":"page"},{"location":"Tutorial/#(1)-Setting-up-the-problem-description","page":"Quick Start","title":"(1) Setting up the problem description","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The problems description involves the physically description of the wind farm, the turbines,  and the wind resource. While this tutorial uses the same design across all the wind turbines and mostly equal properties across all wind flow states, all turbines and flow states can  be unique.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"For API demonstration purposes, we have directly assigned all values. However, values may  be loaded from .csv and/or .yaml files.","category":"page"},{"location":"Tutorial/#Set-up-the-running-environment","page":"Quick Start","title":"Set up the running environment","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFarm; const ff = FLOWFarm\nusing PyPlot; const plt = PyPlot\nusing VectorizedRoutines.Matlab: meshgrid\nusing SNOW","category":"page"},{"location":"Tutorial/#Initialize-the-wind-farm-design","page":"Quick Start","title":"Initialize the wind farm design","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"\n# set initial turbine x and y locations\nturbinex = [-240.0, -240.0, -240.0, 0.0, 0.0, 0.0, 240.0, 240.0, 240.0]\nturbiney = [-240.0, 0.0, 240.0, -240.0, 0.0, 240.0, -240.0, 0.0, 240.0]\n\n# get the number of turbines\nnturbines = length(turbinex)\n\n# set turbine base heights\nturbinez = zeros(nturbines)\n\n# set turbine yaw values\nturbineyaw = zeros(nturbines)\n\n# set wind farm boundary parameters in meters (we won't really need this until we optimize)\nboundarycenter = [0.0,0.0]\nboundaryradius = hypot(300, 300) \nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/#Initialize-wind-turbine-design","page":"Quick Start","title":"Initialize wind turbine design","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set turbine design parameters (these values correspond to the Vestas V80 turbine)\nrotordiameter = zeros(nturbines) .+ 80.0   # m\nhubheight = zeros(nturbines) .+ 70.0           # m\ncutinspeed = zeros(nturbines) .+ 4.0           # m/s\ncutoutspeed = zeros(nturbines) .+ 25.0         # m/s\nratedspeed = zeros(nturbines) .+ 16.0          # m/s\nratedpower = zeros(nturbines) .+ 2.0E6         # W\ngeneratorefficiency = ones(nturbines)\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/#Visualize-the-wind-farm-layout","page":"Quick Start","title":"Visualize the wind farm layout","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# initialize axis \nfig, ax = plt.subplots(1)\n\n# plot layout using FLOWFarm\nff.plotlayout!(ax, turbinex, turbiney, rotordiameter)\n\n# Label the axes\nax.set(xlabel=\"Easting (m)\", ylabel=\"Northing (m)\")\n\n# add farm boundary\ncircle = matplotlib.patches.Circle((0.0, 0.0), boundaryradius, fill=false, color=\"k\")\nax.add_patch(circle)\n\n# set plot limits\nax.set(xlim=[-boundaryradius, boundaryradius].*1.01, ylim=[-boundaryradius, boundaryradius].*1.01)\n\nplt.tight_layout() # hide\nplt.savefig(\"initiallayout.png\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"Tutorial/#Determine-how-to-sample-the-flow-field-to-determine-effective-inflow-speeds","page":"Quick Start","title":"Determine how to sample the flow field to determine effective inflow speeds","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Rotor swept area sample points are normalized by the rotor radius. These arrays define which which points on the rotor swept area should be used to estimate the effective inflow wind speed for each wind turbine. Values of 0.0 are at the rotor hub, 1.0 is at the blade tip, z is vertical, and y is horizontal. These points track the rotor when yawed.  A single sample point will always be placed at the hub. More points can be arranged in  either a grid pattern or a sunflower packing pattern with various options.  See doc strings for more information.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# get the sample points\nnsamplepoints = 50\nrotorsamplepointsy, rotorsamplepointsz = ff.rotor_sample_points(nsamplepoints, method=\"sunflower\")\n\n# visualize the sample points\nfig, ax = plt.subplots(1)\nff.plotrotorsamplepoints!(ax, rotorsamplepointsy, rotorsamplepointsz)\nax.set(xlabel=\"y/radius\", ylabel=\"z/radius\")\nplt.tight_layout() # hide\nplt.savefig(\"rotorsamplepoints.png\") # hide\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"Tutorial/#Setting-up-the-wind-resource","page":"Quick Start","title":"Setting up the wind resource","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wind resource determines the properties of the flowfield at all wind states. A wind  state is any combination of wind speed, wind direction, turbulence intensity, etc...","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set flow parameters\nwindspeed = 8.0        # m/2\nairdensity = 1.1716    # kg/m^3\nambientti = 0.1      # %\nshearexponent = 0.15\nndirections = 5\nwinddirections = collect(range(0, 2*pi*(1-1/ndirections), length=ndirections))   # radians\nwindspeeds = ones(ndirections).*windspeed   # m/s\nwindprobabilities = ones(ndirections).*(1.0/ndirections)       # %\nambienttis = ones(ndirections).*ambientti  # %\nmeasurementheight = ones(ndirections).*hubheight[1] # m\n\n# initialize the wind shear model\nwindshearmodel = ff.PowerLawWindShear(shearexponent)\n\n# initialize the wind resource definition\nwindresource = ff.DiscretizedWindResource(winddirections, windspeeds, windprobabilities, \nmeasurementheight, airdensity, ambienttis, windshearmodel)\n\n# visualize the wind resource\nff.plotwindresource!(windresource)\nplt.tight_layout() # hide\nplt.savefig(\"windresource.png\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"Tutorial/#(2)-Setting-up-the-analysis-models","page":"Quick Start","title":"(2) Setting up the analysis models","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"A model set requires a Wake Deficit Model, Wake Deflection Model, Wake Combination Model, and a Local Turbulence Intensity Model. There are several options for each model type. To facilitate research studies, any of the models in each type can be used with any of the models in any other type. However, behavior is not guaranteed. It is recommended that common, validated, model combinations be used in most cases.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Model types and options are:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Deficit Models: JensenTopHat, JensenCosine, MultiZone, GaussOriginal, GaussYaw, GaussYawVariableSpread, GaussSimple\nDeflection Models: GaussYawDeflection, GaussYawVariableSpreadDeflection, JiminezYawDeflection, MultizoneDeflection\nCombination Models: LinearFreestreamSuperposition, SumOfSquaresFreestreamSuperposition SumOfSquaresLocalVelocitySuperposition, LinearLocalVelocitySuperposition\nTurbulence Models: LocalTIModelNoLocalTI, LocalTIModelMaxTI","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The model set can be set up as follows:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize power model (this is a simple power model based only on turbine design and is not very accurate. For examples on how to use more accurate power models, look at the example optimization scripts)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"powermodel = ff.PowerModelPowerCurveCubic()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The user can define different power models for different wind turbines, but here we use the same power model for every turbine. The initialization of the power_models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"powermodels = Vector{typeof(powermodel)}(undef, nturbines)\nfor i = 1:nturbines\n    powermodels[i] = powermodel\nend","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize thrust model(s). The user can provide a complete thrust curve. See the example scripts for details on initializing them. The initialization of the ct models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"ctmodel = ff.ThrustModelConstantCt(0.65)\nctmodels = Vector{typeof(ctmodel)}(undef, nturbines)\nfor i = 1:nturbines\n    ctmodels[i] = ctmodel\nend","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Set up wake and related models. Here we will use the default values provided in FLOWFarm. However, it is important to use the correct model parameters. More information and references are provided in the doc strings attached to each model.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake deficit model predicts the impact of wind turbines wake on the wind speed.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakedeficitmodel = ff.GaussYawVariableSpread()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake deflection model predicts the cross-wind location of the center of a wind turbine wake.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakedeflectionmodel = ff.GaussYawDeflection()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake combination model defines how the predicted deficits in each wake should be combined to predict the total deficit at a point","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakecombinationmodel = ff.LinearLocalVelocitySuperposition()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The local turbulence intensity models can be used to estimate the local turbulence intensity at each wind turbine or point to provide more accurate input information to the wake and deflection models if applicable.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"localtimodel = ff.LocalTIModelMaxTI()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize model set. This is just a convenience container for the analysis models.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"modelset = ff.WindFarmModelSet(wakedeficitmodel, wakedeflectionmodel, wakecombinationmodel, localtimodel)\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/#(3)-Running-the-analysis","page":"Quick Start","title":"(3) Running the analysis","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Now that the wind farm and analysis models have been defined, we can calculate AEP. The output is in Watt-hours.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"aep = ff.calculate_aep(turbinex, turbiney, turbinez, rotordiameter,\n    hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n    cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n    rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"We can also get the AEP in each direction using the following.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"state_aeps = ff.calculate_state_aeps(turbinex, turbiney, turbinez, rotordiameter,\n        hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n        cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n        rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz, \n        hours_per_year=365.25*24.0, weighted=true)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"If we instead set weighted=false then we would get the power in each direction in Watts.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"If we want to get the individual turbine powers in each directions, we use the following.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"turbine_powers_by_direction = ff.calculate_state_turbine_powers(turbinex, turbiney, turbinez, rotordiameter,\n    hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n    cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n    rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The output shows each turbine power in an array that is ndirections by nturbines.","category":"page"},{"location":"Tutorial/#(4)-setting-up-and-running-an-optimization","page":"Quick Start","title":"(4) setting up and running an optimization","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFarm is specifically designed for efficient optimization using gradient-based optimization methods. Besides the steps outlined above, we need to define the following before we can run  and optimization:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(1) Optimization related variables\n(1) A container for non-differentiated parameters\n(2) Objective function \n(3) Constraint function(s) \n(4) Optimization tool specific items","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"In this tutorial we demonstrate optimizing using the IPOPT algorithms via SNOW.jl for simplicity.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"First, set up optimization related variables. We will have two constraints, one to keep  turbines from getting too close to each other (spacing), and the other to keep turbines  inside the desired area (boundary). FLOWFarm provides several different ways of handling  boundary constraints, including concave boundaries. However, for this tutorial we will use  a simple circular boundary.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# scale objective derivatives to be between 0 and 1\nobjectivescale = 1E-6\n\n# scale boundary constraint derivatives to be between 0 and 1\nconstraintscaleboundary = 1.0E-3\n\n# scale spacing constraint derivatives to be between 0 and 1\nconstraintscalespacing = 1.0\n\n# set the minimum spacing between turbines \nminimumspacing = 160.0\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Next, set up a container for non-differentiated parameters","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set up a struct for use in optimization functions\nmutable struct params_struct{}\n    modelset\n    rotorsamplepointsy\n    rotorsamplepointsz\n    turbinez\n    ambientti\n    rotordiameter\n    boundarycenter\n    boundaryradius\n    objectivescale\n    constraintscaleboundary\n    constraintscalespacing\n    minimumspacing\n    hubheight\n    turbineyaw\n    ctmodels\n    generatorefficiency\n    cutinspeed\n    cutoutspeed\n    ratedspeed\n    ratedpower\n    windresource\n    powermodels\nend\n\nparams = params_struct(modelset, rotorsamplepointsy, rotorsamplepointsz, turbinez, ambientti, \n    rotordiameter, boundarycenter, boundaryradius, objectivescale, constraintscaleboundary,\n    constraintscalespacing, minimumspacing, hubheight, turbineyaw, \n    ctmodels, generatorefficiency, cutinspeed, cutoutspeed, ratedspeed, ratedpower, \n    windresource, powermodels)\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Now we are ready to set up wrapper functions for the objective and constraints.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set up boundary constraint wrapper function\nfunction boundary_wrapper(x, params)\n    # include relevant params\n    boundarycenter = params.boundarycenter\n    boundaryradius = params.boundaryradius\n    constraintscaleboundary = params.constraintscaleboundary\n\n    # find the number of turbines\n    nturbines = Int(length(x)/2)\n    \n    # extract x and y locations of turbines from design variables vector\n    turbinex = x[1:nturbines]\n    turbiney = x[nturbines+1:end]\n\n    # get and return boundary distances\n    return ff.circle_boundary(boundarycenter, boundaryradius, turbinex, turbiney).*constraintscaleboundary\nend\n\n# set up spacing constraint wrapper function\nfunction spacing_wrapper(x, params)\n    # include relevant params\n    rotordiameter = params.rotordiameter\n    constraintscalespacing = params.constraintscalespacing\n    minimumspacing = params.minimumspacing\n\n    # get number of turbines\n    nturbines = Int(length(x)/2)\n\n    # extract x and y locations of turbines from design variables vector\n    turbinex = x[1:nturbines]\n    turbiney = x[nturbines+1:end]\n\n    # get and return spacing distances\n    return constraintscalespacing.*(minimumspacing .- ff.turbine_spacing(turbinex,turbiney))\nend\n\n# set up aep wrapper function\nfunction aep_wrapper(x, params)\n\n    # include relevant params\n    turbinez = params.turbinez\n    rotordiameter = params.rotordiameter\n    hubheight = params.hubheight\n    turbineyaw =params.turbineyaw\n    ctmodels = params.ctmodels\n    generatorefficiency = params.generatorefficiency\n    cutinspeed = params.cutinspeed\n    cutoutspeed = params.cutoutspeed\n    ratedspeed = params.ratedspeed\n    ratedpower = params.ratedpower\n    windresource = params.windresource\n    powermodels = params.powermodels\n    modelset = params.modelset\n    rotorsamplepointsy = params.rotorsamplepointsy\n    rotorsamplepointsz = params.rotorsamplepointsy\n    objectivescale = params.objectivescale\n\n    # get number of turbines\n    nturbines = Int(length(x)/2)\n\n    # extract x and y locations of turbines from design variables vector\n    turbinex = x[1:nturbines] \n    turbiney = x[nturbines+1:end]\n\n    # calculate AEP\n    aep = objectivescale*ff.calculate_aep(turbinex, turbiney, turbinez, rotordiameter,\n                hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n                cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n                rotor_sample_points_y=rotorsamplepointsy,rotor_sample_points_z=rotorsamplepointsz)\n    \n    # return the AEP\n    return aep\nend\n\n# set up optimization problem wrapper function\nfunction wind_farm_opt!(g, x, params)\n\n    nturbines = Int(length(x)/2)\n\n    # calculate spacing constraint value and jacobian\n    spacing_con = spacing_wrapper(x, params)\n\n    # calculate boundary constraint and jacobian\n    boundary_con = boundary_wrapper(x, params)\n\n    # combine constaint values and jacobians into overall constaint value and jacobian arrays\n    g[1:(end-nturbines)] = spacing_con[:]\n    g[end-nturbines+1:end] = boundary_con[:]\n    \n    # calculate the objective function and jacobian (negative sign in order to maximize AEP)\n    obj = -aep_wrapper(x, params)[1]\n    \n    return obj\nend\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Because the optimizer will need to call the objective function without knowing about the params, we need to set up a method that will know the params values by default.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# generate objective function wrapper\nobj_func!(g, x) = wind_farm_opt!(g, x, params)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Next we set up the optimizer.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# initialize design variable vector\nx0 = [copy(turbinex);copy(turbiney)]\n\n# set general lower and upper bounds for design variables\nlx = zeros(length(x0)) .- boundaryradius\nux = zeros(length(x0)) .+ boundaryradius\n\n# set general lower and upper bounds for constraints\nng = Int(nturbines + (nturbines)*(nturbines - 1)/2)\nlg = [-Inf*ones(Int((nturbines)*(nturbines - 1)/2)); -Inf*ones(nturbines)]\nug = [zeros(Int((nturbines)*(nturbines - 1)/2)); zeros(nturbines)]\n\n# IPOPT options\nip_options = Dict(\n    \"max_iter\" => 50,\n    \"tol\" => 1e-6\n)\nsolver = IPOPT(ip_options)\n\n# if using SNOPT, you can do the following instead:\n# snopt_opt = Dict(\n#    \"Derivative option\" => 1,\n#    \"Major optimality tolerance\" => 1e-4,\n# )\n# solver = SNOPT(options=snopt_opt)\n\n# initialize SNOW options\noptions = Options(solver=solver, derivatives=ForwardAD())  # choose AD derivatives\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Now that the optimizer is set up, we are ready to optimize and check the results.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# optimize\nt1 = time() # start time\nxopt, fopt, info, out = minimize(obj_func!, x0, ng, lx, ux, lg, ug, options)\nt2 = time() # end time\nclk = t2-t1 # approximate run time\n\n# get final aep\naepfinal = -fopt/objectivescale\n\n# print optimization results \nprintln(\"Finished in : \", clk, \" (s)\")\nprintln(\"info: \", info)\nprintln(\"Initial AEP: \", aep)\nprintln(\"Final AEP: \", aepfinal)\nprintln(\"AEP improvement (%) = \", 100*(aepfinal - aep)/aep) \n\n# extract final turbine locations\nturbinexopt = copy(xopt[1:nturbines])\nturbineyopt = copy(xopt[nturbines+1:end])\n\n# initialize figure and axes object\nfig, ax = plt.subplots(1)\n\n# plot layout using FLOWFarm\nff.plotlayout!(ax, turbinexopt, turbineyopt, rotordiameter)\n\n# label the axes\nax.set(xlabel=\"Easting (m)\", ylabel=\"Northing (m)\")\n\n# and the wind farm boundary\ncircle = matplotlib.patches.Circle((0.0, 0.0), boundaryradius, fill=false, color=\"k\")\nax.add_patch(circle)\n\n# set limits on the plot region\nax.set(xlim=[-boundaryradius, boundaryradius].*1.01, ylim=[-boundaryradius, boundaryradius].*1.01)\n\nplt.tight_layout() # hide\nplt.savefig(\"optlayout.png\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"Tutorial/#(5)-Calculating-and-visualizing-a-flow-field","page":"Quick Start","title":"(5) Calculating and visualizing a flow field","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"It is helpful to visualize the whole flow-field, not just the turbine powers. Here we will  visualize the flow field for a 2D horizontal cross-section at the hub height. FLOWFarm is  capable of generating flow fields in 1D, 2D, and 3D.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# define how many points should be in the flow field\nxres = 1000\nyres = 1000\nzres = 1\n\n# define flow field domain\nmaxy = boundaryradius*1.5\nminy = -boundaryradius*1.5\nmaxx = boundaryradius*1.5\nminx = -boundaryradius*1.5\n\n# set up point grid for flow field\nxrange = minx:(maxx-minx)/xres:maxx\nyrange = miny:(maxy-miny)/yres:maxy\nzrange = hubheight[1]\n\n# run flowfarm \nffvelocities = ff.calculate_flow_field(xrange, yrange, zrange,\n    modelset, turbinexopt, turbineyopt, turbinez, turbineyaw,\n    rotordiameter, hubheight, ctmodels, rotorsamplepointsy, rotorsamplepointsz,\n    windresource, wind_farm_state_id=5)\n\n# visualize \n\n# initialize figure\nfig, ax = plt.subplots(1)\n\n# generate meshgrid from ranges for passing to pyplots\nxg, yg = meshgrid(collect(xrange), collect(yrange))\n\n# plot as filled contours\ncs = ax.contourf(xg, yg, ffvelocities[1,:,:], cmap=\"Blues_r\")\n\n# add colorbar \ncbar = ax.figure.colorbar(cs, ax=ax, label=\"Wind Speed (m/s)\", orientation=\"vertical\")\n\n# label the axes\nax.set(xlabel=\"Easting (m)\", ylabel=\"Northing (m)\")\n\n# add the wind farm boundary\ncircle = matplotlib.patches.Circle((0.0, 0.0), boundaryradius, fill=false, color=\"k\")\nax.add_patch(circle)\n\nplt.savefig(\"flowfield.png\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"Explanation/#Explanation","page":"Theory","title":"Explanation","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"This section consists primarily of citations of relevant papers where details about each  model can be found. It is admittedly incomplete, but will hopefully be expanded over time.","category":"page"},{"location":"Explanation/#Wake-Deficit-Models","page":"Theory","title":"Wake Deficit Models","text":"","category":"section"},{"location":"Explanation/#Jensen","page":"Theory","title":"Jensen","text":"","category":"section"},{"location":"Explanation/#JensenTopHat","page":"Theory","title":"JensenTopHat","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[1] N. O. Jensen. A note on wind generator interaction. Technical report, Risø National Laboratory, DK-4000 Roskilde, Denmark, November 1983.","category":"page"},{"location":"Explanation/#JensenCosine","page":"Theory","title":"JensenCosine","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[1] N. O. Jensen. A note on wind generator interaction. Technical report, Risø National Laboratory, DK-4000 Roskilde, Denmark, November 1983.\n[2] J. J. Thomas, S. McOmber, and A. Ning. Wake expansion continuation: Multi-modality reduction in the wind farm layout optimization problem. Wind Energy, May 2021. (in review).","category":"page"},{"location":"Explanation/#MultiZone","page":"Theory","title":"MultiZone","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Simply put, three jensen top-hat models stacked on top of each other to approximate varrying behavior in different wake zones.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[3] P. M. O. Gebraad, F. W. Teeuwisse, J. W. van Wingerden, P. A. Fleming, S. D. Ruben, J. R. Marden, and L. Y. Pao. Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study. Wind Energy, 2014.","category":"page"},{"location":"Explanation/#Gaussian","page":"Theory","title":"Gaussian","text":"","category":"section"},{"location":"Explanation/#GaussOriginal","page":"Theory","title":"GaussOriginal","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[4] M. Bastankhah and F. Port ́e-Agel. A new analytical model for wind-turbine wakes. Renewable Energy, 70:116–123, 2014.","category":"page"},{"location":"Explanation/#GaussYaw","page":"Theory","title":"GaussYaw","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.","category":"page"},{"location":"Explanation/#GaussYawVariableSpread","page":"Theory","title":"GaussYawVariableSpread","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.\n[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.","category":"page"},{"location":"Explanation/#GaussSimple","page":"Theory","title":"GaussSimple","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[7] N. F. Baker, A. P. J. Stanley, J. J. Thomas, A. Ning, and K. Dykes. Best practices for wake model and optimization algorithm selection in wind farm layout optimization. In AIAA Scitech 2019 Forum, San Diego, CA, Jan. 2019.","category":"page"},{"location":"Explanation/#Wake-Deflection-Models","page":"Theory","title":"Wake Deflection Models","text":"","category":"section"},{"location":"Explanation/#Jimenez","page":"Theory","title":"Jimenez","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[8] A ́. Jim ́enez, A. Crespo, and E. Migoya. Application of a LES technique to chracterize the wake deflection of a wind turbine in yaw. Wind Energy, 13:559–572, 2010.","category":"page"},{"location":"Explanation/#MultiZone-2","page":"Theory","title":"MultiZone","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[3] P. M. O. Gebraad, F. W. Teeuwisse, J. W. van Wingerden, P. A. Fleming, S. D. Ruben, J. R. Marden, and L. Y. Pao. Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study. Wind Energy, 2014.\n[9] J. Thomas, P. Gebraad, and A. Ning. Improving the FLORIS wind plant model for compatibility with gradient-based optimization. Wind Engineering, Aug. 2017.","category":"page"},{"location":"Explanation/#Gauss","page":"Theory","title":"Gauss","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.","category":"page"},{"location":"Explanation/#Wake-Combination-Models","page":"Theory","title":"Wake Combination Models","text":"","category":"section"},{"location":"Explanation/#LinearFreestreamSuperposition","page":"Theory","title":"LinearFreestreamSuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[10] P. Lissaman. Energy effectiveness of arbitrary arrays of wind turbines. Journal of Energy, 3:323–328, 1979.","category":"page"},{"location":"Explanation/#SumOfSquaresFreestreamSuperposition","page":"Theory","title":"SumOfSquaresFreestreamSuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[11] I. Katic, J. Højstrup, and N. Jensen. A simple model for cluster efficiency. In European Wind Energy Association Conference and Exhibition, Rome - Italy, October 1986. European Wind Energy Association.","category":"page"},{"location":"Explanation/#SumOfSquaresLocalVelocitySuperposition","page":"Theory","title":"SumOfSquaresLocalVelocitySuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[12] S. Voutsinas, K. Rados, and A. Zervos. On the analysis of wake effects in wind parks. Wind Engineering, 14:204–2019, 1990.","category":"page"},{"location":"Explanation/#LinearLocalVelocitySuperposition","page":"Theory","title":"LinearLocalVelocitySuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.","category":"page"},{"location":"Explanation/#Local-Turbulence-Intensity-Models","page":"Theory","title":"Local Turbulence Intensity Models","text":"","category":"section"},{"location":"Explanation/#LocalTIModelNoLocalTI","page":"Theory","title":"LocalTIModelNoLocalTI","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Just like it sounds. Local TI is ignored and ambient TI is used anywhere TI is called for in the calculations.","category":"page"},{"location":"Explanation/#LocalTIModelMaxTI","page":"Theory","title":"LocalTIModelMaxTI","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.s","category":"page"},{"location":"Explanation/#GaussianTI","page":"Theory","title":"GaussianTI","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Not currently connected with the general wind farm models, but it hopefully will be eventually.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[13] A. Pen ̃a, K. Schaldemose Hansen, S. Ott, and M. P. van der Laan. On wake modeling, wind-farm gradients, and aep predictions at the anholt wind farm. Wind Energy Science, 3(1):191–202, 2018.","category":"page"},{"location":"Explanation/#Wake-Expansion-Continuation-(WEC)","page":"Theory","title":"Wake Expansion Continuation (WEC)","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[2] J. J. Thomas, S. McOmber, and A. Ning. Wake expansion continuation: Multi-modality reduction in the wind farm layout optimization problem. Wind Energy, May 2021. (in review).","category":"page"},{"location":"Explanation/#Wind-Shear","page":"Theory","title":"Wind Shear","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Wind shear refers to the fact that the wind speed changes with elevation. For wind farms, that change is due to the boundary layer of the wind flowing over the earth. The boundary layer is the region where the flow transitions from stationary at the ground, to some free-stream speed at some distance above the ground. ","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Wind shear in FLOWFarm is handled using a power law","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"u = u_r bigfracz-z_0z_r-z_0big^phi","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"where u is the wind speed at the desired height (z), z_r is the height of the known speed (u_r), and z_0 is the height of the ground (which is zero for flat terrain). The value of phi controls how quickly the wind speed transitions from zero to the free-stream velocity.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"The models used by FLOWFarm are simple engineering models and do not account for wind shear. To apply wind shear, we first adjust the inflow speed using the wind shear equation and then apply the wake deficit for the given point. ","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"using FLOWFarm; const ff = FLOWFarm\n\n# set input values\nshear_exponent = 0.15\nlocz = 40.0 # height above ground in meters\nreference_velocity = 8.0 # in m/s\nreference_height = 80.0 # height of reference velocity in meters\nground_height = 0.0 # height where velocity goes to zero\n\n# initialize wind shear model instance\nwind_shear_model = ff.PowerLawWindShear(shear_exponent)\n\n# adjust wind speed for wind shear\nff.adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, wind_shear_model)\n\n# output\n7.2100037008866416","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"using FLOWFarm; const ff = FLOWFarm\nusing PyPlot; const plt = PyPlot\n\n# set input values\nshear_exponent = 0.15\nreference_velocity = 8.0 # in m/s\nreference_height = 80.0 # height of reference velocity in meters\nground_height = 0.0 # height where velocity goes to zero\n\n# initialize wind shear model instance\nwind_shear_model = ff.PowerLawWindShear(shear_exponent, ground_height)\n\n# initialize heights of interest\nh = 0:200\n\n# initialize array for wind speeds at the heights of interest\ns = zeros(length(h))\n\n# adjust wind speed for heights of interest based on the the reference speed and height\nfor i = 1:length(h)\n    s[i] = ff.adjust_for_wind_shear(h[i], reference_velocity, reference_height, ground_height, wind_shear_model)\nend\n\n# Scatter plot with some custom settings\nplt.plot(s, h)\nplt.title(\"Wind Shear\")\nplt.xlabel(\"Speed (m/s)\")\nplt.ylabel(\"Height (m)\")\nplt.savefig(\"windshear.png\") # hide","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Citing:","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[1] N. O. Jensen. A note on wind generator interaction. Technical report, Risø National Laboratory, DK-4000 Roskilde, Denmark, November 1983.\n[2] J. J. Thomas, S. McOmber, and A. Ning. Wake expansion continuation: Multi-modality reduction in the wind farm layout optimization problem. Wind Energy, May 2021. (in review).\n[3] P. M. O. Gebraad, F. W. Teeuwisse, J. W. van Wingerden, P. A. Fleming, S. D. Ruben, J. R. Marden, and L. Y. Pao. Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study. Wind Energy, 2014.\n[4] M. Bastankhah and F. Port ́e-Agel. A new analytical model for wind-turbine wakes. Renewable Energy, 70:116–123, 2014.\n[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.\n[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.\n[7] N. F. Baker, A. P. J. Stanley, J. J. Thomas, A. Ning, and K. Dykes. Best practices for wake model and optimization algorithm selection in wind farm layout optimization. In AIAA Scitech 2019 Forum, San Diego, CA, Jan. 2019.\n[8] A ́. Jim ́enez, A. Crespo, and E. Migoya. Application of a LES technique to chracterize the wake deflection of a wind turbine in yaw. Wind Energy, 13:559–572, 2010.\n[9] J. Thomas, P. Gebraad, and A. Ning. Improving the FLORIS wind plant model for compatibility with gradient-based optimization. Wind Engineering, Aug. 2017.\n[10] P. Lissaman. Energy effectiveness of arbitrary arrays of wind turbines. Journal of Energy, 3:323–328, 1979.\n[11] I. Katic, J. Højstrup, and N. Jensen. A simple model for cluster efficiency. In European Wind Energy Association \n[12] S. Voutsinas, K. Rados, and A. Zervos. On the analysis of wake effects in wind parks. Wind Engineering, 14:204–2019, 1990.\n[13] A. Pen ̃a, K. Schaldemose Hansen, S. Ott, and M. P. van der Laan. On wake modeling, wind-farm gradients, and aep predictions at the anholt wind farm. Wind Energy Science, 3(1):191–202, 2018.","category":"page"},{"location":"#FLOWFarm.jl","page":"Intro","title":"FLOWFarm.jl","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Summary: Wind farm simulation tool for gradient-based optimization.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Authors: Jared J. Thomas, Andrew P.J. Stanley","category":"page"},{"location":"#Features","page":"Intro","title":"Features","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Swap out models without changing anything else in the simulation setup\nSmooth/continous model implementations\nRuns on a single core, across multiple cores (threaded), or on multiple machines (distributed).\nDesigned so that new model implementations can be included by adding a single method\nAllows for Wake Expansion Continuation (WEC) as described here","category":"page"},{"location":"#Installation","page":"Intro","title":"Installation","text":"","category":"section"},{"location":"#Install-FLOWFarm","page":"Intro","title":"Install FLOWFarm","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"(v1.x) pkg> dev https://github.com/byuflowlab/FLOWFarm.jl.git","category":"page"},{"location":"#Enable-NaN-Safe-Mode-in-ForwardDiff","page":"Intro","title":"Enable NaN Safe Mode in ForwardDiff","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"NaN Safe Mode must be enables in ForwardDiff for ForwardDiff to work properly with FLOWFarm.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"(v1.x) pkg> dev ForwardDiff","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"$ cd ~/.julia/dev/ForwardDiff/src/","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"In prelude.jl, on the first line, set const NANSAFE_MODE_ENABLED = true and save the file.  For more information see the ForwardDiff documentation at  http://www.juliadiff.org/ForwardDiff.jl/latest/user/advanced.html","category":"page"},{"location":"#Testing","page":"Intro","title":"Testing","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"To test FLOWFarm, run the following from the top directory:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"julia\n]\nactivate .\ntest","category":"page"},{"location":"#Documentation","page":"Intro","title":"Documentation","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Begin with the quick start tutorial.\nMore advanced topics are covered in the how-to guide.\nTheory details, and links, can be found in the theory page.\nDoc strings can be found in the references page.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Citing: Thomas, McOmber, and Ning \"Wake Expansion Continuation: Multi-Modality Reduction in the Wind Farm Layout Optimization Problem\" Wind Energy (in review), –>","category":"page"}]
}
