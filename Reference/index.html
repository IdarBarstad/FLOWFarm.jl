<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · FLOWFarm.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLOWFarm.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Intro</a></li><li><a class="tocitem" href="../Tutorial/">Quick Start</a></li><li><a class="tocitem" href="../How_to/">How-to Guide</a></li><li><a class="tocitem" href="../Explanation/">Theory</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/master/docs/src/Reference.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.DiscretizedWindResource" href="#FLOWFarm.DiscretizedWindResource"><code>FLOWFarm.DiscretizedWindResource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscritizedWindResource(wind_directions, wind_speeds, wind_probabilities, measurement_heights, air_density, ti_model, wind_shear_model)

Struct defining a wind resource</code></pre><p><strong>Arguments</strong></p><ul><li><code>wind_directions::Array{Float,1}(Nstates)</code>: an array of wind directions corresponding to each wind farm state in radians</li><li><code>wind_speeds::Array{Float,1}(Nstates)</code>: an array of wind speeds corresponding to each wind farm state in meters/second</li><li><code>wind_probabilities::Array{Float,1}(Nstates)</code>: an array of probabilities corresponding to each wind farm state with values in [0,1]</li><li><code>measurement_heights::Array{Float,1}(Nstates)</code>: an array of measurement heights corresponding to each wind farm state</li><li><code>air_density::Float</code>: the air density</li><li><code>ambient_ti::Array{Float,1}</code>: an array of the ambient turbulence intensity for each wind direction</li><li><code>wind_shear_model::Array{AbstractWindShearModel}(1)</code>: contains a struct defining the desired turbulence intensity model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wind_resources.jl#LL5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussOriginal" href="#FLOWFarm.GaussOriginal"><code>FLOWFarm.GaussOriginal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussOriginal(k_star)</code></pre><p>Container for parameters related to the origina Gaussian deficit model presented by Bastankhah and Porte-Agel 2014</p><p><strong>Arguments</strong></p><ul><li><code>k_star::Float</code>: parameter controlling the wake spreading rate and deficit decay. Default value is 0.075</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussSimple" href="#FLOWFarm.GaussSimple"><code>FLOWFarm.GaussSimple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussSimple(k, wec_factor)</code></pre><p>Container for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016</p><p><strong>Arguments</strong></p><ul><li><code>k::Float</code>: parameter controlling the spread of the wake</li><li><code>wec_factor::Array{Float}</code>: parameter artificial wake spreading for wake expansion continuation (WEC) optimization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL110-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussYaw" href="#FLOWFarm.GaussYaw"><code>FLOWFarm.GaussYaw</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussYaw(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)</code></pre><p>Container for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016</p><p><strong>Arguments</strong></p><ul><li><code>horizontal_spread_rate::Float</code>: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.</li><li><code>vertical_spread_rate::Float</code>: parameter controlling the vertical spread of the deficit model. Default value is 0.022.</li><li><code>alpha_star::Float</code>: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.</li><li><code>beta_star::Float</code>: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussYawDeflection" href="#FLOWFarm.GaussYawDeflection"><code>FLOWFarm.GaussYawDeflection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussYawDeflection(horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)</code></pre><p>Container for parameters related to the Gaussian deflection model presented by Bastankhah and Porte-Agel 2016</p><p><strong>Arguments</strong></p><ul><li><code>horizontal_spread_rate::Float</code>: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.</li><li><code>vertical_spread_rate::Float</code>: parameter controlling the vertical spread of the deficit model. Default value is 0.022.</li><li><code>alpha_star::Float</code>: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.</li><li><code>beta_star::Float</code>: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussYawVariableSpread" href="#FLOWFarm.GaussYawVariableSpread"><code>FLOWFarm.GaussYawVariableSpread</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussYawVariableSpread(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)</code></pre><p>Container for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016     and the farm model presented by Niayifar and Porte-Agel in 2016.</p><p><strong>Arguments</strong></p><ul><li><code>alpha_star::Float</code>: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.</li><li><code>beta_star::Float</code>: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL89-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussYawVariableSpreadDeflection" href="#FLOWFarm.GaussYawVariableSpreadDeflection"><code>FLOWFarm.GaussYawVariableSpreadDeflection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GaussYawDeflectionVariableSpread(alpha_star, beta_star, k1, k2, wec_factor)</code></pre><p>Container for parameters related to the Gaussian deflection model with yaw presented by Bastankhah and Porte-Agel 2016</p><p><strong>Arguments</strong></p><ul><li><code>alpha_star::Float</code>: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.</li><li><code>beta_star::Float</code>: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.</li><li><code>k1::Float</code>: first parameter tuning wake spread as based on turbulence intensity</li><li><code>k2::Float</code>: second parameter tuning wake spread as based on turbulence intensity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL30-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.JensenCosine" href="#FLOWFarm.JensenCosine"><code>FLOWFarm.JensenCosine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JensenCosine(alpha)</code></pre><p>Container for parameters related to the Jensen Cosine deficit model</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Float</code>: parameter controlling the wake deficit decay rate. Default value is 0.1</li><li><code>beta::Float</code>: parameter controlling the width of the cosine function. Default value is 20.0 deg., given in radians.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.JensenTopHat" href="#FLOWFarm.JensenTopHat"><code>FLOWFarm.JensenTopHat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JensenTopHat(alpha)</code></pre><p>Container for parameters related to the Jensen Top Hat deficit model</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Float</code>: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.JiminezYawDeflection" href="#FLOWFarm.JiminezYawDeflection"><code>FLOWFarm.JiminezYawDeflection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JiminezYawDeflection(horizontal_spread_rate)</code></pre><p>Container for parameters related to the Jiminez deflection model</p><p><strong>Arguments</strong></p><ul><li><code>horizontal_spread_rate::Float</code>: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.Levelized" href="#FLOWFarm.Levelized"><code>FLOWFarm.Levelized</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Levelized(TCC, BOS, FC, FCR, OpEx)</code></pre><p>Container for parameters related to the Levelized Cost of Energy model (NREL 2016 Cost of Wind Energy)</p><p><strong>Arguments</strong></p><p><strong>Arguments</strong></p><ul><li><code>TCC::Float</code>: Turbine Capital Cost not including the tower module</li><li><code>BOS::Float</code>: Balance of System (Costs outside of turbine i.e. operation and maintenance)</li><li><code>FC::Float</code>: Financial Costs including construction and contingency</li><li><code>FCR::Float</code>: Fixed Charge Rate</li><li><code>OpEx::Float</code>: Operational Expenditures</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/cost_models.jl#LL3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.LocalTIModelMaxTI" href="#FLOWFarm.LocalTIModelMaxTI"><code>FLOWFarm.LocalTIModelMaxTI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalTIModelMaxTI(astar, bstar, k1, k2)</code></pre><p>Calculate local turbulence intensity using the model presented in Niayifar and  Porte Agel (2015, 2016)</p><p><strong>Arguments</strong></p><ul><li><code>astar::Float</code>: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model</li><li><code>bstar::Float</code>: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model</li><li><code>k1::Float</code>: slope of k vs TI curve</li><li><code>k2::Float</code>: vertical offset of k vs TI curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/local_turbulence_intensity_models.jl#LL14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.LocalTIModelNoLocalTI" href="#FLOWFarm.LocalTIModelNoLocalTI"><code>FLOWFarm.LocalTIModelNoLocalTI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalTIModelNoLocalTI()</code></pre><p>Don&#39;t calculate local turbulence intensity. Ambient TI will be used instead for all points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/local_turbulence_intensity_models.jl#LL3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.MultiZone" href="#FLOWFarm.MultiZone"><code>FLOWFarm.MultiZone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiZone(me, ke, MU, aU, bU)</code></pre><p>Container for parameters related to the MultiZone deficit model</p><p><strong>Arguments</strong></p><ul><li><code>me::Float</code>: parameter controlling general wake expansion. Default value is 0.065</li><li><code>ke::Array{Float}(3)</code>: parameters controlling the wake expansion of each zone respectively. Default values are [-0.5 0.22 1.0].</li><li><code>MU::Array{Float}(3)</code>: parameters controlling the wake deficit decay of each zone respectively. Default values are [0.5 1.0 5.5].</li><li><code>aU::Float</code>: parameter impacting the wake deficit decay for a constant wake deflection. Default value is 5.0.</li><li><code>bU::Float</code>: parameter changing the wake deficit decay under yawed conditions. Default value is 1.66.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL34-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.MultizoneDeflection" href="#FLOWFarm.MultizoneDeflection"><code>FLOWFarm.MultizoneDeflection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultizoneDeflection(horizontal_spread_rate)</code></pre><p>Container for parameters related to the Jiminez deflection model</p><p><strong>Arguments</strong></p><ul><li><code>horizontal_spread_rate::Float</code>: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1</li><li><code>ad::Float</code>:Helps define the horizontal deflection of the wake at 0 deg yaw</li><li><code>bd::Float</code>:Helps define the horizontal deflection of the wake due to downwind distance at 0 deg yaw</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL63-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.NoYawDeflection" href="#FLOWFarm.NoYawDeflection"><code>FLOWFarm.NoYawDeflection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoYawDeflection()</code></pre><p>Allows for bypassing deflection calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.PowerLawWindShear" href="#FLOWFarm.PowerLawWindShear"><code>FLOWFarm.PowerLawWindShear</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerLawWindShear(shear_exponent, ground_height)</code></pre><p>Provides shear exponent and ground height to define wind shear curve. Ground height may be tuned because the power law does not always hold near the ground.</p><p><strong>Arguments</strong></p><ul><li><code>shear_exponent::Float</code>: defines trajectory of wind shear</li><li><code>ground_height::Float</code>: height of the ground (typically zero)</li><li><code>shear_order::Bool</code>: when shear should be calculated. Can be &quot;first&quot;, &quot;last&quot;, or &quot;none&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wind_shear_models.jl#LL3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.PowerModelConstantCp" href="#FLOWFarm.PowerModelConstantCp"><code>FLOWFarm.PowerModelConstantCp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModelConstantCp(cp)</code></pre><p>Models will assume a constant cp value as provided</p><p><strong>Arguments</strong></p><ul><li><code>cp::Float</code>: constant power coefficient value</li><li>&#39;pp::TI&#39;: exponent for adjusting power for wind turbine yaw</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.PowerModelCpPoints" href="#FLOWFarm.PowerModelCpPoints"><code>FLOWFarm.PowerModelCpPoints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModelCpPoints(vel_points, cp_points)</code></pre><p>Models will use adjust cp based on cp curve using linear interpolation of provided points</p><p><strong>Arguments</strong></p><ul><li><code>vel_points::Array{N,Float}</code>: wind speed values in m/s</li><li><code>cp_points::Array{N,Float}</code>: power coefficient values corresponding to the provided speeds</li><li>&#39;pp::TF&#39;: exponent for adjusting power for wind turbine yaw</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.PowerModelPowerCurveCubic" href="#FLOWFarm.PowerModelPowerCurveCubic"><code>FLOWFarm.PowerModelPowerCurveCubic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModelPowerCurveCubic()</code></pre><p>Power will be calculated based on turbine specifications assuming a cubic power curve. Note that this method is inherently incorrect and should only be used for theoretical purposes  or after careful validation.</p><p><strong>Arguments</strong></p><ul><li>&#39;pp::TF&#39;: exponent for adjusting power for wind turbine yaw</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.PowerModelPowerPoints" href="#FLOWFarm.PowerModelPowerPoints"><code>FLOWFarm.PowerModelPowerPoints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModelPowerPoints(vel_points, cp_points)</code></pre><p>Models will use adjust wind turbine power based on power curve using linear interpolation of  provided points</p><p><strong>Arguments</strong></p><ul><li><code>vel_points::Array{N,Float}</code>: wind speed values in m/s</li><li><code>power_points::Array{N,Float}</code>: power values corresponding to the provided speeds</li><li>&#39;pp::TF&#39;: exponent for adjusting power for wind turbine yaw</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL35-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.ThrustModelConstantCt" href="#FLOWFarm.ThrustModelConstantCt"><code>FLOWFarm.ThrustModelConstantCt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThrustModelConstantCt(ct::Float)</code></pre><p>Stores a constant ct value for wake calculations</p><p><strong>Arguments</strong></p><ul><li><code>ct::Float</code>: a constant ct value for computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/thrust_coefficient_models.jl#LL3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.ThrustModelCtPoints" href="#FLOWFarm.ThrustModelCtPoints"><code>FLOWFarm.ThrustModelCtPoints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThrustModelCtPoints(vel_points, ct_points)</code></pre><p>Stores the thrust coefficient curve in terms of corresponding velocity and thrust coefficient points. ct and velocity points should be in the same order and ordered from lowest wind speed to highest wind speed.</p><p><strong>Arguments</strong></p><ul><li><code>inflow_velocity::Float</code>: inflow velocity of the wind turbine</li><li><code>thrust_model::ThrustModelCtPoints</code>: Struct containing ct and velocity points for ct curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/thrust_coefficient_models.jl#LL15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.WindFarm" href="#FLOWFarm.WindFarm"><code>FLOWFarm.WindFarm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>WindFarm(windfarm, windresource, windfarmstates)</p><p>Struct defining a wind farm</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float}(Nturbines)</code>: contains windturbine x coordinates in the global reference frame</li><li><code>turbine_y::Array{Float}(Nturbines)</code>: contains windturbine y coordinates in the global reference frame</li><li><code>turbine_z::Array{Float}(Nturbines)</code>: contains windturbine base/z coordinates in the global reference frame</li><li><code>turbine_definition_ids::Array{Int}(Nturbines)</code>: contains integers for each wind turbine specifying its definition</li><li><code>turbine_definitions::Array{AbstractTurbineDefinition}(Ntypes)</code>: contains structs defining each wind turbine definition (design) used in the farm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/windfarms.jl#LL4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.WindFarmModelSet" href="#FLOWFarm.WindFarmModelSet"><code>FLOWFarm.WindFarmModelSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WindFarmModelSet(wakedeficitmodel, wake_deflection_model, wake_combination_model, local_ti_model)</code></pre><p>Container for objects defining models to use in wind farm calculations</p><p><strong>Arguments</strong></p><ul><li><code>wake_defiict_model::AbstractWakeDeficitModel</code>: contains a struct defining the desired wake deficit model</li><li><code>wake_deflection_model::AbstractWakeDeflectionModel</code>: contains a struct defining the desired wake deflection model</li><li><code>wake_combination_model::AbstractWakeCombinationModel</code>: contains a struct defining the desired wake combination model</li><li><code>local_ti_model::AbstractTurbulenceIntensityModel</code>: contains a struct defining the desired turbulence intensity model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/general_models.jl#LL5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.DiscreteCircum" href="#FLOWFarm.DiscreteCircum"><code>FLOWFarm.DiscreteCircum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PointsOnCircum(center_x, center_y, r, n = 100)</code></pre><p>Given a circle center, radius, and number of discrete points, returns an array of discrete points along the circle&#39;s circumference</p><p><strong>Arguments</strong></p><ul><li><code>center_x::Float64</code> : cartesian x-coordinate for the center of the circle</li><li><code>center_y::Float64</code> : cartesian y-coordinate for the center of the circle</li><li><code>r::Float64</code> : distance from circle&#39;s center to the circumference points</li><li><code>n::Float64</code> : defaults to 100, is the number of discrete evenly-spaced points       that will be returned along the circle&#39;s circumference</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL343-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.GaussianTI-NTuple{8, Any}" href="#FLOWFarm.GaussianTI-NTuple{8, Any}"><code>FLOWFarm.GaussianTI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GaussianTI(loc,turbine_x, turbine_y, rotor_diameter, hub_height, turbine_ct, 
    sorted_turbine_index, ambient_ti; div_sigma=2.5, div_ti=1.2)</code></pre><p>Calculate local turbulence intensity based on &quot;On wake modeling, wind-farm gradients and AEP      predictions at the Anholt wind farm&quot; by Pena Diaz, Alfredo; Hansen, Kurt Schaldemose;      Ott, Søren; van der Laan, Paul ??</p><p><strong>Arguments</strong></p><ul><li><code>loc::Array{Float,3}</code>: [x,y,z] location of point of interest in wind direction ref. frame</li><li><code>turbine_x::Array{Float,nTurbines}</code>: turbine wind direction locations in the wind direction    reference frame</li><li><code>turbine_y::Array{Float,nTurbines}</code>: turbine cross wind locations in the wind direction    reference frame</li><li><code>rotor_diameter::Array{Float,nTurbines}</code>: rotor diameters of all turbines</li><li><code>hub_height::Array{Float,nTurbines}</code>: hub heights of all turbines relative to the ground</li><li><code>turbine_ct::Array{Float,nTurbines}</code>: thrust coefficient of each turbine for the given state</li><li><code>sorted_turbine_index::Array{Float,nTurbines}</code>: turbine north-south locations in the    global reference frame</li><li><code>ambient_ti::Float</code>: ambient turbulence intensity</li><li><code>div_sigma::Float</code>: ?</li><li><code>div_ti::Float</code>: ?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/local_turbulence_intensity_models.jl#LL267-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.VR_boundary-NTuple{5, Any}" href="#FLOWFarm.VR_boundary-NTuple{5, Any}"><code>FLOWFarm.VR_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VR_boundary(bndry_x_clsd, bndry_y_clsd, start_dist, turb_spacing, num_turbs, bndry_seg_length)</code></pre><p>Uses the Boundary portion of Boundary-Grid variable reduction method place turbines along a closed wind farm boundary and perturb their location with one (1) variable &lt;start<em>dist&gt;.  NOTE: Use of this function assumes prior use of VR</em>bounary_startup(), which ensures the number of turbines placed on the boundary doesn&#39;t violate any minimum spacing rules eiter along the boundary or around corners.</p><p><strong>Arguments</strong></p><ul><li><code>bndry_x::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_y::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li><li><code>start_dist::Float64</code>: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed</li><li><code>turb_spacing::Float64</code>: the fixed distance along the boundary&#39;s edge between       adjacent turbines</li><li>&#39;num<em>turbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VR</em>bounary_startup() has already been       run so that the user won&#39;t attempt to place too many turbines.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL467-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.VR_boundary_startup-NTuple{5, Any}" href="#FLOWFarm.VR_boundary_startup-NTuple{5, Any}"><code>FLOWFarm.VR_boundary_startup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VR_bounary_startup(bndry_x_clsd, bndry_y_clsd, start_dist, turb_min_spacing, num_turbs)</code></pre><p>Determines if the requested number of turbines can be placed along the closed boundary with spacing and corner constraints. If the requested &lt;num_turbs&gt; is too many, places as many turbines as possible along the boundary, and returns the number of turbines not placed. NOTE: A shortcoming is that the smallest-angled corner limits the spacing of all turbines. in the worst case, a very thin boundary area would prevent any more than one turbine being placed on the boundary, though more would be optimal. Future work would check to make sure this corner (and the length of its adjacent sides) don&#39;t actually require limiting the minimum distance between turbines.</p><p><strong>Arguments</strong></p><ul><li><code>bndry_x::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_y::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li><li><code>start_dist::Float64</code>: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed</li><li><code>turb_min_spacing::Float64</code>: the fixed distance along the boundary&#39;s edge between       adjacent turbines</li><li>&#39;num<em>turbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VR</em>bounary_startup() has already been       run so that the user won&#39;t attempt to place too many turbines.</li><li>&#39;bndry<em>seg</em>length::Array{Int}`: an array of the lengths between adjacent       boundary verticies, corresponding to how they appear in bndry_x and _y</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL408-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm._ct_to_axial_ind_func-Tuple{Any}" href="#FLOWFarm._ct_to_axial_ind_func-Tuple{Any}"><code>FLOWFarm._ct_to_axial_ind_func</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_ct_to_axial_ind_func(ct)</code></pre><p>Calculate axial induction from the thrust coefficient. See Gebraad et. al. 2017  &quot;Maximization of the Annual Energy Production of Wind Power Plants by Optimization of  Layout and Yaw-Based Wake Control&quot;</p><p><strong>Arguments</strong></p><ul><li><code>ct::Float</code>: thrust coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/thrust_coefficient_models.jl#LL76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm._gauss_yaw_potential_core-NTuple{6, Any}" href="#FLOWFarm._gauss_yaw_potential_core-NTuple{6, Any}"><code>FLOWFarm._gauss_yaw_potential_core</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_gauss_yaw_potential_core(dt, yaw, ct, as, ti, bs)</code></pre><p>Helper function for wake<em>deficit</em>model when using the GaussYaw model. Computes the length of the near wake potential core.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm._gauss_yaw_spread-NTuple{5, Any}" href="#FLOWFarm._gauss_yaw_spread-NTuple{5, Any}"><code>FLOWFarm._gauss_yaw_spread</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_gauss_yaw_spread(dt, k, dx, x0, yaw)</code></pre><p>Helper function for wake<em>deficit</em>model when using the GaussYaw model. Computes the standard deviation of the wake.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL488-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm._gauss_yaw_spread_interpolated-NTuple{6, Any}" href="#FLOWFarm._gauss_yaw_spread_interpolated-NTuple{6, Any}"><code>FLOWFarm._gauss_yaw_spread_interpolated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_gauss_yaw_spread_interpolated(dt, k, dx, x0, yaw)</code></pre><p>Helper function for wake<em>deficit</em>model when using the GaussYaw model. Computes the standard deviation of the wake. with an interpolation on the near wake. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL501-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm._niayifar_added_ti_function-NTuple{12, Any}" href="#FLOWFarm._niayifar_added_ti_function-NTuple{12, Any}"><code>FLOWFarm._niayifar_added_ti_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_niayifar_added_ti_function(x, d_dst, d_ust, h_ust, h_dst, ct_ust, kstar_ust, delta_y, 
    ti_amb, ti_ust, ti_dst, ti_area_ratio_in; s=700.0)</code></pre><p>Main code for calculating the local turbulence intensity at a turbine using the method of     Niayifar and Porte Agel (2015, 2016).</p><p><strong>Arguments</strong></p><ul><li><code>x::Float</code>: downstream distance from turbine to point of interest</li><li><code>d_dst::Float</code>: downstream turbine rotor diameter</li><li><code>d_ust::Float</code>: upstream turbine rotor diameter</li><li><code>h_ust::Float</code>: upstream turbine hub height</li><li><code>h_dst::Float</code>: downstream turbine hub height</li><li><code>ct_ust::Float</code>: upstream turbine thrust coefficient</li><li><code>kstar_ust::Float</code>: upstream turbine wake expansion rate</li><li><code>delta_y::Float</code>: cross wind separation from turbine to point of interest</li><li><code>ti_amb::Float</code>: ambient turbulence intensity</li><li><code>ti_ust::Float</code>: upstream turbine local turbulence intensity</li><li><code>ti_dst::Float</code>: downstream turbine local turbulence intensity</li><li><code>ti_area_ratio_in::Float</code>: current value of TI-area ratio for use in calculatin local TI</li><li><code>s::Float</code>: smooth max smootheness parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/local_turbulence_intensity_models.jl#LL86-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm._remove_out_of_bounds_points-Tuple{Any, Any, Any}" href="#FLOWFarm._remove_out_of_bounds_points-Tuple{Any, Any, Any}"><code>FLOWFarm._remove_out_of_bounds_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_remove_perimeter_points!(n; alpha=0.0)</code></pre><p>Internal function. Removes points outside or outside and on the border of the rotor-swept      area </p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractArray</code>: horizontal point locations</li><li><code>z::AbstractArray</code>: vertical point locations </li><li><code>use_perimeter_points::Bool</code>: flag that determines whether or not to include points on the    boundary of the rotor-swept area</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL541-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.add_turbine!-Tuple{Any}" href="#FLOWFarm.add_turbine!-Tuple{Any}"><code>FLOWFarm.add_turbine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_turbine!(ax; view=&quot;side&quot;, hubdiameter=0.1, hubheight=0.9, radius=0.5, chord=0.1, 
    nacellewidth=0.3, nacelleheight=0.1, towerbottomdiam=0.1, towertopdiam=0.05, 
    overhang=0.05, s=5)

Convenience function for adding wind turbines to plots.</code></pre><p><strong>Arguments</strong></p><ul><li><code>ax::PyCall.PyObject</code>: pre-initialized axis from pyplot</li><li><code>view::Number</code>: determines which turbine view to use &quot;top&quot; or &quot;side&quot; (default)</li><li><code>hubdiameter::Number</code>: hub diameter in axis coordinate frame</li><li><code>hubheight::Number</code>: hub height in axis coordinate frame</li><li><code>radius::Number</code>: full rotor radius in axis coordinate frame</li><li><code>chord::Number</code>: maximum chord in axis coordinate frame</li><li><code>nacellewidth::Number</code>: nacelle width in axis coordinate frame</li><li><code>nacelleheight::Number</code>: nacelle height in axis coordinate frame</li><li><code>towerbottomdiam::Number</code>: tower bottom diameter in axis coordinate frame</li><li><code>towertopdiam::Number</code>: tower top diameter in axis coordinate frame</li><li><code>overhang::Number</code>: overhang (distance from blade attachment to tower bottom in x axis) in axis coordinate frame</li><li><code>s::Number</code>: scales overhang and tower location in x direction to work with condensed x axis as in long contour plots</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL341-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.adjust_for_wind_shear-Tuple{Any, Any, Any, Any, FLOWFarm.PowerLawWindShear}" href="#FLOWFarm.adjust_for_wind_shear-Tuple{Any, Any, Any, Any, FLOWFarm.PowerLawWindShear}"><code>FLOWFarm.adjust_for_wind_shear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, model::PowerLawWindShear)</code></pre><p>Uses provided velocity at a given height to estimate the velocity at a different height due to wind shear. Ground height may be tuned because the power law does not always hold near the ground.</p><p><strong>Arguments</strong></p><ul><li><code>locz::Float</code>: height of desired velocity</li><li><code>reference_velocity::Float</code>: known velocity at reference_height</li><li><code>reference_height::Float</code>: height of known velocity </li><li><code>ground_height::Float</code>: height of the ground (typically zero)</li><li><code>model::AbstractWindShearModel</code>: wind shear model to use for calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wind_shear_models.jl#LL25-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.boundary_normals_calculator-Tuple{Any}" href="#FLOWFarm.boundary_normals_calculator-Tuple{Any}"><code>FLOWFarm.boundary_normals_calculator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boundary_normals_calculator(boundary_vertices; nboundaries=1)</code></pre><p>Outputs the unit vectors perpendicular to each edge of each polygon in a set of polygons,  given the Cartesian coordinates for each polygon&#39;s vertices.</p><p><strong>Arguments</strong></p><ul><li><code>boundary_vertices::Array{Float,1}</code> : ragged array of arrays containing all the boundary vertices of each polygon, counterclockwise</li><li><code>nboundaries::Int</code> : the number of boundaries in the set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL517-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calcMinorAngle" href="#FLOWFarm.calcMinorAngle"><code>FLOWFarm.calcMinorAngle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calcMinorAngle(bndry_x, bndry_y, bndry_z=[0,0,0])</code></pre><p>Given three points in space, calculates the magnitude of the non-reflex angle formed at the center point. Created to be used in VR<em>bounary</em>startup()</p><p><strong>Arguments</strong></p><ul><li><code>bndry_x::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_y::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_z::Array{Float,1}</code> : 1-D array of z-coordinates for the vertices       around a singlar closed boundary. Default to [0,0,0] for X-Y plane</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL366-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calcSmallestAngle-Tuple{Any, Any}" href="#FLOWFarm.calcSmallestAngle-Tuple{Any, Any}"><code>FLOWFarm.calcSmallestAngle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calcSmallestAngle(bndry_x_clsd, bndry_y_clsd)</code></pre><p>Given a 1-D closed array of boundary verticies (with first point repeated at the end) it determines the smallest non-reflex angle created by any three consecutive verticies along the boundary. Created to be used in VR<em>bounary</em>startup()</p><p><strong>Arguments</strong></p><ul><li><code>bndry_x::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_y::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL403-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calc_moment_stress" href="#FLOWFarm.calc_moment_stress"><code>FLOWFarm.calc_moment_stress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_moment_stress(mx,my,dx,dy,Rcyl=1.771,tcyl=0.06)</code></pre><p>Calculates stresses from bending moments on a hollow cylinder</p><p><strong>Arguments</strong></p><ul><li><code>mx::Float</code>: x moment</li><li><code>my::Float</code>: y moment</li><li><code>dx::Float</code>: x distance to the location of interest</li><li><code>dy::Float</code>: y distance to the location of interest</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>Rcyl::Float</code>: radius of the cylinder</li><li><code>tcyl::Float</code>: thickenss of the cylinder</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL169-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_aep-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}" href="#FLOWFarm.calculate_aep-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}"><code>FLOWFarm.calculate_aep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_aep(turbine_x, turbine_y, turbine_z, rotor_diameter,
hub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,
cut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;
rotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0], hours_per_year=365.25*24.0)</code></pre><p>Calculate wind farm AEP</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float,nTurbines}</code>: turbine east-west locations in the global    reference frame</li><li><code>turbine_y::Array{Float,nTurbines}</code>: turbine north-south locations in the global    reference frame</li><li><code>turbine_z::Array{Float,nTurbines}</code>: turbine base height in the global reference frame</li><li><code>rotor_diameter::Array{Float,nTurbines}</code></li><li><code>hub_height::Array{TF,nTurbines}</code>: turbine hub heights</li><li><code>turbine_yaw::Array{TF,nTurbines}</code>: turbine yaw for the given wind direction in    radians</li><li><code>ct_model::AbstractThrustCoefficientModel</code>: defines how the thrust coefficient changes    with state etc</li><li><code>generator_efficiency::Array{Float,nTurbines}</code></li><li><code>cut_in_speed::Array{Float,nTurbines}</code> </li><li><code>cut_out_speed::Array{Float,nTurbines}</code></li><li><code>rated_speed::Array{Float,nTurbines}</code></li><li><code>rated_power::Array{Float,nTurbines}</code></li><li><code>wind_resource::DiscretizedWindResource</code>: wind resource discreption (directions, speeds,    frequencies, etc)</li><li><code>power_model::Array{)</code>: elements of array should be sub types of AbstractPowerModel</li><li><code>model_set::AbstractModelSet</code>: defines wake-realated models to be used in analysis</li><li><code>rotor_sample_points_y::Array{TF,N}</code>: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) </li><li><code>rotor_sample_points_z::Array{TF,N}</code>: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)</li><li><code>hours_per_year::Float</code>: hours per year (averaged for leap year by default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL582-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelConstantCt}" href="#FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelConstantCt}"><code>FLOWFarm.calculate_ct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_ct(model::ThrustModelConstantCt)</code></pre><p>Calculate the thrust coefficient for a wind turbine based on a pre-determined constant ct</p><p><strong>Arguments</strong></p><ul><li><code>inflow_velocity::Float</code>: inflow velocity of the wind turbine (unused for const. ct)</li><li><code>thrust_model::ThrustModelConstantCt</code>: struct containing a constant ct value for computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/thrust_coefficient_models.jl#LL31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelCtPoints}" href="#FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelCtPoints}"><code>FLOWFarm.calculate_ct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_ct(inflow_velocity, thrust_model::ThrustModelCtPoints)

Calculate the thrust coefficient for a wind turbine based on a pre-determined ct curve
    with linear interpolation.</code></pre><p><strong>Arguments</strong></p><ul><li><code>inflow_velocity::Float</code>: inflow velocity of the wind turbine</li><li><code>thrust_model::ThrustModelCtPoints</code>: Struct containing ct and velocity points for ct curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/thrust_coefficient_models.jl#LL44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_flow_field-Tuple{Any, Any, Any, FLOWFarm.AbstractModelSet, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#FLOWFarm.calculate_flow_field-Tuple{Any, Any, Any, FLOWFarm.AbstractModelSet, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>FLOWFarm.calculate_flow_field</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calculate<em>flow</em>field(xrange, yrange, zrange, model<em>set::AbstractModelSet, turbine</em>x,      turbine<em>y, turbine</em>z, turbine<em>yaw, turbine</em>ct, turbine<em>ai, rotor</em>diameter, hub<em>height,      turbine</em>local<em>ti, sorted</em>turbine<em>index, wtvelocities, wind</em>resource; wind<em>farm</em>state_id=1)</p><p>Generates a flow field for a given state and cross section</p><p><strong>Arguments</strong></p><ul><li><code>xrange::Range</code>: range defining east-west locations to sample in global reference frame</li><li><code>yrange::Range</code>: range defining north-west locations to sample in global reference frame</li><li><code>zrange::Range</code>: range defining vertical locations to sample in global reference frame</li><li><code>model_set::AbstractModelSet</code>: defines wake-realated models to be used in analysis</li><li><code>turbine_x::Array{TF,nTurbines}</code>: turbine east-west locations in the global    reference frame</li><li><code>turbine_y::Array{TF,nTurbines}</code>: turbine north-south locations in the global    reference frame</li><li><code>turbine_z::Array{TF,nTurbines}</code>: turbine base height in the global reference frame</li><li><code>turbine_yaw::Array{TF,nTurbines}</code>: turbine yaw for the given wind direction in    radians</li><li><code>turbine_ct::Array{TF,nTurbines}</code>: thrust coefficient of each turbine for the given state</li><li><code>turbine_ai::Array{TF,nTurbines}</code>: turbine axial induction for the given state</li><li><code>rotor_diameter::Array{TF,nTurbines}</code>: turbine rotor diameters</li><li><code>hub_height::Array{TF,nTurbines}</code>: turbine hub heights</li><li><code>turbine_local_ti::Array{TF,nTurbines}</code>: turbine local turbulence intensity for    the given state</li><li><code>sorted_turbine_index::Array{TF,nTurbines}</code>: turbine north-south locations in the    global reference frame</li><li><code>wtvelocities::Array{TF,nTurbines}</code>: effective inflow wind speed for given state</li><li><code>wind_resource::DiscretizedWindResource</code>: wind resource discreption (directions, speeds,    frequencies, etc)</li><li><code>wind_farm_state_id::Int</code>: index to correct state to use from wind resource provided.   Defaults to 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/general_models.jl#LL361-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelMaxTI}" href="#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelMaxTI}"><code>FLOWFarm.calculate_local_ti</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,
turbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelMaxTI; turbine_id=1, tol=1E-6)</code></pre><p>Returns local turbulence intensity calculated using Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float,nTurbines}</code>: turbine wind direction locations in the wind direction    reference frame</li><li><code>turbine_y::Array{Float,nTurbines}</code>: turbine cross wind locations in the wind direction    reference frame</li><li><code>ambient_ti::Float</code>: ambient turbulence intensity</li><li><code>rotor_diameter::Array{Float,nTurbines}</code>: rotor diameters of all turbines</li><li><code>hub_height::Array{Float,nTurbines}</code>: hub heights of all turbines relative to the ground</li><li><code>turbine_yaw::Array{Float,nTurbines}</code>: yaw of all turbines for the current wind state in radians</li><li><code>turbine_local_ti::Array{Float,nTurbines}</code>: local turbulence intensity of all turbines for the current wind state`</li><li><code>sorted_turbine_index::Array{Float,nTurbines}</code>: turbine north-south locations in the    global reference frame</li><li><code>turbine_inflow_velcities::Array{Float,nTurbines}</code>: effective inflow wind speed at each turbine for given state</li><li><code>turbine_ct::Array{Float,nTurbines}</code>: thrust coefficient of each turbine for the given state</li><li><code>ti_model::LocalTIModelMaxTI</code>: contains a struct defining the desired turbulence intensity model, no local TI in this case</li><li><code>turbine_id::Int</code>: index of wind turbine of interest. Provide 1 as default.</li><li><code>tol::Float</code>: How far upstream a turbine should be before being included in TI calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/local_turbulence_intensity_models.jl#LL157-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelNoLocalTI}" href="#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelNoLocalTI}"><code>FLOWFarm.calculate_local_ti</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,
turbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelNoLocalTI; turbine_id=1, tol=1E-6)</code></pre><p>Returns ambient turbulence intesity value whenever local turbulence intensity is requestesd</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float,nTurbines}</code>: turbine wind direction locations in the wind direction    reference frame</li><li><code>turbine_y::Array{Float,nTurbines}</code>: turbine cross wind locations in the wind direction    reference frame</li><li><code>ambient_ti::Float</code>: ambient turbulence intensity</li><li><code>rotor_diameter::Array{Float,nTurbines}</code>: rotor diameters of all turbines</li><li><code>hub_height::Array{Float,nTurbines}</code>: hub heights of all turbines relative to the ground</li><li><code>turbine_yaw::Array{Float,nTurbines}</code>: yaw of all turbines for the current wind state in radians</li><li><code>turbine_local_ti::Array{Float,nTurbines}</code>: local turbulence intensity of all turbines for the current wind state`</li><li><code>sorted_turbine_index::Array{Float,nTurbines}</code>: turbine north-south locations in the    global reference frame</li><li><code>turbine_inflow_velcities::Array{Float,nTurbines}</code>: effective inflow wind speed at each turbine for given state</li><li><code>turbine_ct::Array{Float,nTurbines}</code>: thrust coefficient of each turbine for the given state</li><li><code>ti_model::LocalTIModelNoLocalTI</code>: contains a struct defining the desired turbulence intensity model, no local TI in this case</li><li><code>turbine_id::Int</code>: index of wind turbine of interest. Provide 1 as default.</li><li><code>tol::Float</code>: How far upstream a turbine should be before being included in TI calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/local_turbulence_intensity_models.jl#LL35-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelConstantCp}" href="#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelConstantCp}"><code>FLOWFarm.calculate_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, power_model)</code></pre><p>Calculate the power for a wind turbine based on standard theory for region 2 using a constant cp</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Float</code>: Efficiency of the turbine generator</li><li><code>air_density::Float</code>: Air density</li><li><code>rotor_area::Float</code>: Rotor-swept area of the wind turbine</li><li><code>wt_velocity::Float</code>: Inflow velocity to the wind turbine</li><li><code>cut_in_speed::Float</code>: cut in speed of the wind turbine</li><li><code>rated_speed::Float</code>: rated speed of the wind turbine</li><li><code>cut_out_speed::Float</code>: cut out speed of the wind turbine</li><li><code>rated_power::Float</code>: rated power of the wind turbine</li><li><code>power_model::PowerModelConstantCp</code>: Struct containing the cp value to be used in region 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL85-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelCpPoints}" href="#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelCpPoints}"><code>FLOWFarm.calculate_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)</code></pre><p>Calculate the power for a wind turbine based on a cp curve with linear interpolation</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Float</code>: Efficiency of the turbine generator</li><li><code>air_density::Float</code>: Air density</li><li><code>rotor_area::Float</code>: Rotor-swept area of the wind turbine</li><li><code>wt_velocity::Float</code>: Inflow velocity to the wind turbine</li><li><code>cut_in_speed::Float</code>: cut in speed of the wind turbine</li><li><code>rated_speed::Float</code>: rated speed of the wind turbine</li><li><code>cut_out_speed::Float</code>: cut out speed of the wind turbine</li><li><code>rated_power::Float</code>: rated power of the wind turbine</li><li><code>power_model::PowerModelCpPoints</code>: Struct containing the velocity and cp values defining the cp curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL123-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerCurveCubic}" href="#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerCurveCubic}"><code>FLOWFarm.calculate_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)</code></pre><p>Calculates wind turbine power using a cubic estimation based on turbine specifications     as defined in https://github.com/byuflowlab/iea37-wflo-casestudies/blob/master/cs3-4/iea37-cs3-announcement.pdf</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Float</code>: Efficiency of the turbine generator</li><li><code>air_density::Float</code>: Air density</li><li><code>rotor_area::Float</code>: Rotor-swept area of the wind turbine</li><li><code>wt_velocity::Float</code>: Inflow velocity to the wind turbine</li><li><code>cut_in_speed::Float</code>: cut in speed of the wind turbine</li><li><code>rated_speed::Float</code>: rated speed of the wind turbine</li><li><code>cut_out_speed::Float</code>: cut out speed of the wind turbine</li><li><code>rated_power::Float</code>: rated power of the wind turbine</li><li><code>power_model::PowerModelPowerCurveCubic</code>: Empty struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL248-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerPoints}" href="#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerPoints}"><code>FLOWFarm.calculate_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)</code></pre><p>Calculate the power for a wind turbine based on a pre-determined power curve with linear     interpolation</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Float</code>: Efficiency of the turbine generator</li><li><code>air_density::Float</code>: Air density</li><li><code>rotor_area::Float</code>: Rotor-swept area of the wind turbine</li><li><code>wt_velocity::Float</code>: Inflow velocity to the wind turbine</li><li><code>cut_in_speed::Float</code>: cut in speed of the wind turbine</li><li><code>rated_speed::Float</code>: rated speed of the wind turbine</li><li><code>cut_out_speed::Float</code>: cut out speed of the wind turbine</li><li><code>rated_power::Float</code>: rated power of the wind turbine</li><li><code>power_model::PowerModelPowerPoints</code>: Struct containing the velocity and power values   defining the power curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL188-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_power_from_cp-NTuple{6, Any}" href="#FLOWFarm.calculate_power_from_cp-NTuple{6, Any}"><code>FLOWFarm.calculate_power_from_cp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_power_from_cp(generator_efficiency, air_density, rotor_area, cp, wt_velocity)</code></pre><p>Calculate the power for a wind turbine based on standard theory for region 2</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Float</code>: Efficiency of the turbine generator</li><li><code>air_density::Float</code>: Air density</li><li><code>rotor_area::Float</code>: Rotor-swept area of the wind turbine</li><li><code>cp::Float</code>: Power coefficient of the wind turbine</li><li><code>wt_velocity::Float</code>: Inflow velocity to the wind turbine</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL68-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_state_aeps-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}" href="#FLOWFarm.calculate_state_aeps-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}"><code>FLOWFarm.calculate_state_aeps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_state_aeps(turbine_x, turbine_y, turbine_z, rotor_diameter,
hub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,
cut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;
rotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])</code></pre><p>Calculate AEP for each requested state respectively</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float,nTurbines}</code>: turbine east-west locations in the global    reference frame</li><li><code>turbine_y::Array{Float,nTurbines}</code>: turbine north-south locations in the global    reference frame</li><li><code>turbine_z::Array{Float,nTurbines}</code>: turbine base height in the global reference frame</li><li><code>rotor_diameter::Array{Float,nTurbines}</code></li><li><code>hub_height::Array{TF,nTurbines}</code>: turbine hub heights</li><li><code>turbine_yaw::Array{TF,nTurbines}</code>: turbine yaw for the given wind direction in    radians</li><li><code>ct_model::AbstractThrustCoefficientModel</code>: defines how the thrust coefficient changes    with state etc</li><li><code>generator_efficiency::Array{Float,nTurbines}</code></li><li><code>cut_in_speed::Array{Float,nTurbines}</code> </li><li><code>cut_out_speed::Array{Float,nTurbines}</code></li><li><code>rated_speed::Array{Float,nTurbines}</code></li><li><code>rated_power::Array{Float,nTurbines}</code></li><li><code>wind_resource::DiscretizedWindResource</code>: wind resource discreption (directions, speeds,    frequencies, etc)</li><li><code>power_model::Array{nTurbines}</code>: elemenst of array should be sub-types of AbstractPowerModel</li><li><code>model_set::AbstractModelSet</code>: defines wake-realated models to be used in analysis</li><li>rotor<em>sample</em>points_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) </li><li>rotor<em>sample</em>points_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)</li><li><code>hours_per_year::Float</code>: hours per year (averaged for leap year by default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL429-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_state_turbine_powers-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}" href="#FLOWFarm.calculate_state_turbine_powers-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}"><code>FLOWFarm.calculate_state_turbine_powers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_state_turbine_powers(turbine_x, turbine_y, turbine_z, rotor_diameter,
hub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,
cut_out_speed, rated_speed, rated_power, wind_resource, power_models, model_set::AbstractModelSet;
rotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])</code></pre><p>Calculate power for each turbine for all states respectively</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float,nTurbines}</code>: turbine east-west locations in the global    reference frame</li><li><code>turbine_y::Array{Float,nTurbines}</code>: turbine north-south locations in the global    reference frame</li><li><code>turbine_z::Array{Float,nTurbines}</code>: turbine base height in the global reference frame</li><li><code>rotor_diameter::Array{Float,nTurbines}</code></li><li><code>hub_height::Array{TF,nTurbines}</code>: turbine hub heights</li><li><code>turbine_yaw::Array{TF,nTurbines}</code>: turbine yaw for the given wind direction in    radians</li><li><code>ct_model::AbstractThrustCoefficientModel</code>: defines how the thrust coefficient changes    with state etc</li><li><code>generator_efficiency::Array{Float,nTurbines}</code></li><li><code>cut_in_speed::Array{Float,nTurbines}</code> </li><li><code>cut_out_speed::Array{Float,nTurbines}</code></li><li><code>rated_speed::Array{Float,nTurbines}</code></li><li><code>rated_power::Array{Float,nTurbines}</code></li><li><code>wind_resource::DiscretizedWindResource</code>: wind resource discreption (directions, speeds,    frequencies, etc)</li><li><code>power_models::Array{nTurbines}</code>: elemenst of array should be sub-types of AbstractPowerModel</li><li><code>model_set::AbstractModelSet</code>: defines wake-realated models to be used in analysis</li><li>rotor<em>sample</em>points_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) </li><li>rotor<em>sample</em>points_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL359-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.calculate_turbine_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractPowerModel, Any}" href="#FLOWFarm.calculate_turbine_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractPowerModel, Any}"><code>FLOWFarm.calculate_turbine_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_turbine_power(generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, 
rated_power, rotor_diameter, wt_velocity, power_model::AbstractPowerModel, air_density)</code></pre><p>Calculate the power for all wind turbines. Dispaches to desired power model.</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Array{Float,nTurbines}</code></li><li><code>cut_in_speed::Array{Float,nTurbines}</code> </li><li><code>cut_out_speed::Array{Float,nTurbines}</code></li><li><code>rated_speed::Array{Float,nTurbines}</code></li><li><code>rated_power::Array{Float,nTurbines}</code></li><li><code>rotor_diameter::Array{Float,nTurbines}</code></li><li><code>wt_velocity::Array{Float,nTurbines}</code>: turbine effective wind speeds for current state only</li><li>`power_model::AbstractPowerModel)</li><li><code>air_density::Float</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL286-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.circle_boundary-NTuple{4, Any}" href="#FLOWFarm.circle_boundary-NTuple{4, Any}"><code>FLOWFarm.circle_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circle_boundary(center,radius,turbine_x,turbine_y)</code></pre><p>calculate the distance from each turbine to a circular boundary. Negative means the turbine is inside the boundary</p><p><strong>Arguments</strong></p><ul><li><code>center::Float</code>: circular boundary center [x,y]</li><li><code>radius::Float</code>: circulat boundary radius</li><li><code>turbine_x::Array{Float}</code>: turbine x locations</li><li><code>turbine_y::Array{Float}</code>: turbine y locations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL34-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.closeBndryList-Tuple{Any, Any}" href="#FLOWFarm.closeBndryList-Tuple{Any, Any}"><code>FLOWFarm.closeBndryList</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closeBndryList(bndryPts_x, bndryPts_y)</code></pre><p>Appends the 1st element to the end of the coordinate arrays if it is not already repeated. Note, this will only work on 1-D arrays. For an array of 1-D arrays, use <code>closeBndryLists(bndryPts_x, bndryPts_y)</code> (note the plural, not singular &#39;Lists&#39; in the function title)</p><p><strong>Arguments</strong></p><ul><li><code>bndryPts_x::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndryPts_y::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL318-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.closeBndryLists-Tuple{Any, Any}" href="#FLOWFarm.closeBndryLists-Tuple{Any, Any}"><code>FLOWFarm.closeBndryLists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">closeBndryLists(bndryPts_x, bndryPts_y)</code></pre><p>Appends the 1st element to the end of each array for a closed boundary. Note, this will not function properly if there is only one region. For only one region, use <code>closeBndryList(bndryPts_x, bndryPts_y)</code> (note the singular, not plural &#39;List&#39; in the function title)</p><p><strong>Arguments</strong></p><ul><li><code>bndryPts_x::Array{Float,1}</code> : N-D array of x-coordinates for the vertices       around N-many closed boundaries</li><li><code>bndryPts_y::Array{Float,1}</code> : N-D array of y-coordinates for the vertices       around N-many closed boundaries</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL292-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.convex_boundary-NTuple{4, Any}" href="#FLOWFarm.convex_boundary-NTuple{4, Any}"><code>FLOWFarm.convex_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convex_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)</code></pre><p>calculate the distance from each turbine to a possibly non-circular, but convex boundary. Negative means the turbine is inside the boundary</p><p><strong>Arguments</strong></p><ul><li><code>boundary_vertices::Array{Float,2}</code>: vertices of the convex hull CCW in order s.t.       boundaryVertices[i] -&gt; first point of face for unit_normals[i]</li><li><code>boundary_normals::Array{Float,2}</code>: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face</li><li><code>turbine_x::Array{Float}</code>: turbine x locations</li><li><code>turbine_y::Array{Float}</code>: turbine y locations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL56-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.coordDist-NTuple{4, Any}" href="#FLOWFarm.coordDist-NTuple{4, Any}"><code>FLOWFarm.coordDist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coordDist(x1, y1, x2, y2)</code></pre><p>Given a two points (x1, y1) and (x2, y2), returns the euclidean distance between them</p><p><strong>Arguments</strong></p><ul><li><code>x1::Float64</code> : x-coord of the first point</li><li><code>y1::Float64</code> : y-coord of the first point</li><li><code>x2::Float64</code> : x-coord of the second point</li><li><code>y2::Float64</code> : y-coord of the second point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL461-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.distributed_velocity_op" href="#FLOWFarm.distributed_velocity_op"><code>FLOWFarm.distributed_velocity_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distributed_velocity_op(V, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)</code></pre><p>Return the operating points along the blade considering varied inflow along the blade.</p><p><strong>Arguments</strong></p><ul><li><code>V::Array{Float}</code>: velocity inflow at each r</li><li><code>Omega::Float</code>: rotor rotational speed</li><li><code>r::Array{Float}</code>: radial locations of interest</li><li><code>precone::Float</code>: rotor precone angle</li><li><code>yaw::Float</code>: rotor yaw angle</li><li><code>tilt::Float</code>: rotor tilt angle</li><li><code>azimuth::Float</code>: blade azimuth angle</li><li><code>rho::Float</code>: air density</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mu::Float</code>: air viscocity (can usually use the default)</li><li><code>asound::Float</code>: speed of sound (can usually use the default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL85-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.find_upstream_turbines-Tuple{Any, Any, AbstractArray, Any}" href="#FLOWFarm.find_upstream_turbines-Tuple{Any, Any, AbstractArray, Any}"><code>FLOWFarm.find_upstream_turbines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_upstream_turbines(turbinex, turbiney, winddirection, diameter; inverse=false)</code></pre><p>A convenience function to quickly find either which turbines are waked, or those that are  not. </p><p><strong>Arguments</strong></p><ul><li><code>turbinex::Array{T,1}</code>: x locations of turbines in global reference frame </li><li><code>turbiney::Array{T,1}</code>: y locations of turbines in global reference frame</li><li><code>winddirection::Real</code> or <code>winddirection::AbstractArray</code>: wind direction in radians in meteorological coordinates (0 rad. = from North)</li><li><code>diameter::Array{T,1}</code>: diameters of all wind turbines</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL827-L838">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.find_xyz_simple-NTuple{6, Any}" href="#FLOWFarm.find_xyz_simple-NTuple{6, Any}"><code>FLOWFarm.find_xyz_simple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_xyz_simple(x_hub,y_hub,z_hub,r,yaw,azimuth)</code></pre><p>Find the xyz locations of points along a blade given it&#39;s location and azimuth angle. Currently doesn&#39;t consider precone or tilt.</p><p><strong>Arguments</strong></p><ul><li><code>x_hub::Float</code>: x location of hub</li><li><code>y_hub::Float</code>: y location of hub</li><li><code>z_hub::Float</code>: z location of hub (hub height if no topology)</li><li><code>r::Array{Float}</code>: radial locations of interest</li><li><code>precone::Float</code>: rotor precone angle</li><li><code>yaw::Float</code>: rotor yaw angle</li><li><code>azimuth::Float</code>: blade azimuth angle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.getNextFileName" href="#FLOWFarm.getNextFileName"><code>FLOWFarm.getNextFileName</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNextFileName(directory, file_name, file_type)</code></pre><p>Checks if a file of the given directory and name exists. If not, increments to the next index so as not to overwrite previously written files. If it reaches the max number of overwrites, it will default to &lt;directory/file<em>name.file</em>type&gt; To default to this, set &lt;max_check=0&gt; in function call.</p><p><strong>Arguments</strong></p><ul><li><code>directory::String</code>: path/to/write/file/at/</li><li><code>file_name::String</code>: Whatever the name of the file desired</li><li><code>file_type::String</code>: ex &quot;yaml&quot;, &quot;txt&quot;, &quot;csv&quot;, etc...</li><li><code>max_check::Int</code>: the maximum number of files to check</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/io.jl#LL215-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.getPerimeterLength-Tuple{Any, Any}" href="#FLOWFarm.getPerimeterLength-Tuple{Any, Any}"><code>FLOWFarm.getPerimeterLength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getPerimeterLength(bndry_x_clsd, bndry_y_clsd)</code></pre><p>Given a 1-D closed array of boundary verticies (with first point repeated at the end) returns the length along the perimeter. Created to be used in VR<em>bounary</em>startup()</p><p><strong>Arguments</strong></p><ul><li><code>bndry_x::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_y::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL438-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.getUpDwnYvals-NTuple{4, Any}" href="#FLOWFarm.getUpDwnYvals-NTuple{4, Any}"><code>FLOWFarm.getUpDwnYvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getUpDwnYvals(turbine_x, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)</code></pre><p>Supplements FLOWFarm&#39;s splined<em>boundary() function by calculating (for a given x location) the maximum and minimum y-value permitted to remain &quot;inside&quot; the boundary. If turbine</em>x is located left of the boundary&#39;s leftmost vertex or right of the boundary&#39;s rightmost vertex, it return&#39;s that corresponding vertex&#39;s y-value as the max and min, as default. Returns two values, the minimum and maximum interior y-values withing a boundary for the given turbine_x value. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float}</code>: x-value of the turbine being examined</li><li><code>bndry_x_clsd::Array{Float}</code>: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.</li><li><code>bndry_y_clsd::Array{Float}</code>: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.</li><li><code>bndry_corner_indcies::Array{Float}</code>: An array of 3 or 4 indicies in the       bndry<em>x/y</em>clsd arrays that correspond to the three four &quot;corners&quot; used       between splined &quot;sides&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL205-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_boundary_yaml-Tuple{Any}" href="#FLOWFarm.get_boundary_yaml-Tuple{Any}"><code>FLOWFarm.get_boundary_yaml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_boundary_yaml(filename)</code></pre><p>Returns the boundaries of a wind farm as defined in a yaml file in the format used in FLOWFarm. Returns N by 2 array for single region farm and an array of  N by 2 arrays for multiple regions. Returned regions are sorted alphabetically by the keys provided in the yaml file.</p><p><strong>Arguments</strong></p><ul><li><code>file_name::String</code>: relative/path/to/file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/io.jl#LL240-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_moments-NTuple{7, Any}" href="#FLOWFarm.get_moments-NTuple{7, Any}"><code>FLOWFarm.get_moments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_moments(out,Rhub,Rtip,r,az,precone,tilt)</code></pre><p>Trapezoidal integration to find the blade root bending moment using the loads distribution</p><p><strong>Arguments</strong></p><ul><li>`out::CCBlade dict: output from running CCBlade solve</li><li><code>Rhub::Float</code>: radius of the rotor hub</li><li><code>Rtip::Float</code>: radius of the blade tip</li><li><code>r::Array{Float}</code>: radial locations of interest</li><li><code>az::Float</code>: blade azimuth angle</li><li><code>precone::Float</code>: rotor precone angle</li><li><code>tilt::Float</code>: rotor tilt angle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL384-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_peaks-Tuple{Any}" href="#FLOWFarm.get_peaks-Tuple{Any}"><code>FLOWFarm.get_peaks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_peaks(array)</code></pre><p>get the turning point values of a signal</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Float}</code>: the signal to find the turning points, or peaks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL296-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_peaks_indices-Tuple{Any}" href="#FLOWFarm.get_peaks_indices-Tuple{Any}"><code>FLOWFarm.get_peaks_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_peaks_indices(array)</code></pre><p>return the indices of the signal peaks</p><p><strong>Arguments</strong></p><ul><li><code>array::Array{Float}</code>: the signal to find the turning points, or peaks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL335-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_turb_atrbt_YAML-Tuple{Any}" href="#FLOWFarm.get_turb_atrbt_YAML-Tuple{Any}"><code>FLOWFarm.get_turb_atrbt_YAML</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_turb_atrbt_YAML(file_name)</code></pre><p>read in turbine attributes from .yaml</p><p><strong>Arguments</strong></p><ul><li><code>file_name::String</code>: path/to/attribute/file.yaml</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/io.jl#LL44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_turb_loc_YAML-Tuple{Any}" href="#FLOWFarm.get_turb_loc_YAML-Tuple{Any}"><code>FLOWFarm.get_turb_loc_YAML</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_turb_loc_YAML(file_name)</code></pre><p>read in turbine locations and related problem file names from .yaml</p><p><strong>Arguments</strong></p><ul><li><code>file_name::String</code>: path/and/name/of/location/file.yaml</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/io.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.get_wind_rose_YAML-Tuple{Any}" href="#FLOWFarm.get_wind_rose_YAML-Tuple{Any}"><code>FLOWFarm.get_wind_rose_YAML</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_wind_rose_YAML(file_name)</code></pre><p>read in wind resource information from .yaml</p><p><strong>Arguments</strong></p><ul><li><code>file_name::String</code>: path/to/wind/resource/file.yaml</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/io.jl#LL75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.grid_points-Tuple{Any}" href="#FLOWFarm.grid_points-Tuple{Any}"><code>FLOWFarm.grid_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_points(n)</code></pre><p>Generates points in a grid. If n is not a perfect square, then the nearest square root will  be used for the side length of the grid.</p><p><strong>Arguments</strong></p><ul><li><code>n::Float</code>: number of points to generate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL614-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.hermite_spline-NTuple{7, Any}" href="#FLOWFarm.hermite_spline-NTuple{7, Any}"><code>FLOWFarm.hermite_spline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hermite_spline(x, x0, x1, y0, dy0, y1, dy1)</code></pre><p>Produces the y and (optionally) dy values for a hermite cubic spline interpolating between two end points with known slopes</p><p><strong>Arguments</strong></p><ul><li><code>x::Float</code>: x position of output y</li><li><code>x0::Float</code>: x position of upwind endpoint of spline</li><li><code>x1::Float</code>: x position of downwind endpoint of spline</li><li><code>y0::Float</code>: y position of upwind endpoint of spline</li><li><code>dy0::Float</code>: slope at upwind endpoint of spline</li><li><code>y1::Float</code>: y position of downwind endpoint of spline</li><li><code>dy1::Float</code>: slope at downwind endpoint of spline</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.iea37cs4BndryVRIntPM-NTuple{6, Any}" href="#FLOWFarm.iea37cs4BndryVRIntPM-NTuple{6, Any}"><code>FLOWFarm.iea37cs4BndryVRIntPM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iea37cs4BndryVRIntPM(bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbine_x, turbine_y, turb_diam, turb_min_space, num_turbs_to_place)</code></pre><p>Uses the Variable reduction method for placing boundary turbines, and the Partition Method (from splined_boundary()) for random interior points, maintaining proper spacing from all previously placed turbines.</p><p><strong>Arguments</strong></p><ul><li><code>bndry_x_clsd::Array{Float,1}</code> : 1-D array of x-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_y_clsd::Array{Float,1}</code> : 1-D array of y-coordinates for the vertices       around a singlar closed boundary</li><li><code>bndry_corner_indcies::Float64</code>: The indicies within &lt;bndry<em>x</em>clsd&gt; and       &lt;bndry<em>y</em>clsd&gt; which denote the &quot;corners&quot; adjacent turbines</li><li>&#39;turb<em>min</em>space::Float64`: For proximity knowledge, the minimum spacing       required between any two turbines</li><li>&#39;num<em>bndry</em>turbs::Float64`: The number of turbines desired to be placed along       the boundary. If too many are selected (due to spacing condtraints), the       remaining will be placed in the interior</li><li>&#39;num<em>tot</em>turbs::Float64`: The number of total turbines to be placed both on       the boundary and in the interior</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL543-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.latlong_to_xy-Tuple{Any, Any, Any}" href="#FLOWFarm.latlong_to_xy-Tuple{Any, Any, Any}"><code>FLOWFarm.latlong_to_xy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latlong_to_xy(latitude, longitude, utm_zone; isnorth=true, units=&quot;m&quot;)</code></pre><p>Converts arrays of points from latitude and longitude to x and y in meters in a local coordinate frame based on the point with the lowest magnitude latitude,</p><p><strong>Arguments</strong></p><ul><li><code>latitude::Array{Float,N}</code></li><li><code>longitude::Array{Float,N}</code></li><li><code>isnorth::Float</code>: specifies if the point is in the northern hemisphere (defaul: true)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL47-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.met2cart-Tuple{Number}" href="#FLOWFarm.met2cart-Tuple{Number}"><code>FLOWFarm.met2cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">met2cart(angle_met)</code></pre><p>Convert from meteorological polar system (CW, 0 rad.=N, wind from) to cartesian polar system  (CCW, 0 rad.=E, wind to).</p><p><strong>Arguments</strong></p><ul><li><code>angle_met::Number</code>: an angle in radians in a meteorological coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.multiple_components_op" href="#FLOWFarm.multiple_components_op"><code>FLOWFarm.multiple_components_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">multiple_components_op(U, V, W, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)</code></pre><p>Return the operating points along the blade considering all the inflow velocity components.</p><p><strong>Arguments</strong></p><ul><li><code>U::Array{Float}</code>: u velocity component of the inflow at each r</li><li><code>V::Array{Float}</code>: v velocity component of the inflow at each r</li><li><code>W::Array{Float}</code>: w velocity component of the inflow at each r</li><li><code>Omega::Float</code>: rotor rotational speed</li><li><code>r::Array{Float}</code>: radial locations of interest</li><li><code>precone::Float</code>: rotor precone angle</li><li><code>yaw::Float</code>: rotor yaw angle</li><li><code>tilt::Float</code>: rotor tilt angle</li><li><code>azimuth::Float</code>: blade azimuth angle</li><li><code>rho::Float</code>: air density</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mu::Float</code>: air viscocity (can usually use the default)</li><li><code>asound::Float</code>: speed of sound (can usually use the default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.nansafenorm-Tuple{Vector{T} where T}" href="#FLOWFarm.nansafenorm-Tuple{Vector{T} where T}"><code>FLOWFarm.nansafenorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nansafenorm(v)</code></pre><p>Calculate the norm of a vector, but if the sum of the squares is less than the given tolerance  then use the line y = a(sqrt(eps())/eps()) so that the derivative is well defined.</p><p><strong>Arguments</strong></p><ul><li><code>v::Vector{}</code>: takes the norm of this vector, but avoids NaN by using a linear    approximation of sqrt near 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL1586-L1595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.nansafesqrt-Tuple{Number}" href="#FLOWFarm.nansafesqrt-Tuple{Number}"><code>FLOWFarm.nansafesqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nansafesqrt(a)</code></pre><p>Calculate the square root of a number, but if the number is less than the given tolerance  then use the line y = a(sqrt(eps())/eps()) so that the derivative is well defined.</p><p><strong>Arguments</strong></p><ul><li><code>a::Number</code>: takes the square root of this value, or approximates it with a line for a &lt; eps()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL1567-L1575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotboundary!-Tuple{Any, Any}" href="#FLOWFarm.plotboundary!-Tuple{Any, Any}"><code>FLOWFarm.plotboundary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotboundary!(ax, boundary_vertices; color=&quot;k&quot;, linestyle=&quot;-&quot;, nboundaries=1)

Convenience function for plotting wind farm boundaries</code></pre><p><strong>Arguments</strong></p><ul><li>`ax</li><li><code>boundary_vertices::Array{Float,1}(nvertices)</code>: an nx2 array of boundary vertices for polygon or [[center<em>x, center</em>y], radius] for circle boundary</li><li><code>color::=String</code>: sets color for turbine markers</li><li><code>linestyle::String</code>: sets the line style for the boundary</li><li><code>nboundaries::Int</code>: number of discrete boundary regions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotlayout!-NTuple{4, Any}" href="#FLOWFarm.plotlayout!-NTuple{4, Any}"><code>FLOWFarm.plotlayout!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotlayout!(ax, turbinex, turbiney, rotordiameter; aspect=&quot;equal&quot;, xlim=[], ylim=[], fill=false, color=&quot;k&quot;, markeralpha=1, title=&quot;&quot;)

Convenience function for plotting wind farm layouts</code></pre><p><strong>Arguments</strong></p><ul><li>`ax</li><li><code>turbinex::Array{Float,1}(nturbines)</code>: an array x coordinates of wind turbine locations</li><li><code>turbiney::Array{Float,1}(nturbines)</code>: an array y coordinates of wind turbine locations</li><li><code>rotordiameter::Array{Float,1}(nturbines)</code>: an array rotor diameters of wind turbines</li><li><code>aspect::String</code>: set plot aspect ratio, default=&quot;equal&quot;</li><li><code>xlim::Array</code>: limits in x coordinate. &quot;[]&quot; results in limits being automatically defined</li><li><code>ylim::Array</code>: limits in y coordinate. &quot;[]&quot; results in limits being automatically defined</li><li><code>fill::Bool</code>: determines whether turbine circle markers are filled or not</li><li><code>color::=String</code>: sets color for turbine markers</li><li><code>markeralpha::Int</code>: determines tranparancy of turbine markers</li><li><code>itle::String</code>: optional title to include on the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotrotorsamplepoints!-Tuple{Any, Any, Any}" href="#FLOWFarm.plotrotorsamplepoints!-Tuple{Any, Any, Any}"><code>FLOWFarm.plotrotorsamplepoints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotrotorsamplepoints!(ax, y, z; rotordiameter=2.0, aspect=&quot;equal&quot;, ylim=[], zlim=[], fill=false, color=&quot;k&quot;, markeralpha=1, title=&quot;&quot;)

Convenience function for plotting where points are being sampled on the wind turbine rotor</code></pre><p><strong>Arguments</strong></p><ul><li>`ax</li><li><code>y::Array{Float,1}(nturbines)</code>: an array x coordinates of wind turbine locations</li><li><code>z::Array{Float,1}(nturbines)</code>: an array y coordinates of wind turbine locations</li><li><code>rotordiameter::Number</code>: rotor diameter of wind turbine</li><li><code>aspect::String</code>: set plot aspect ratio, default=&quot;equal&quot;</li><li><code>ylim::Array</code>: limits in y coordinate. &quot;[]&quot; results in limits being automatically defined</li><li><code>zlim::Array</code>: limits in z coordinate. &quot;[]&quot; results in limits being automatically defined</li><li><code>fill::Bool</code>: determines whether turbine circle markers are filled or not</li><li><code>color::=String</code>: sets color for turbine markers</li><li><code>markeralpha::Int</code>: determines tranparancy of turbine markers between 0 (transparent) and 1 (opaque)</li><li><code>itle::String</code>: optional title to include on the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL180-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotsingleboundary!-Tuple{Any, Any}" href="#FLOWFarm.plotsingleboundary!-Tuple{Any, Any}"><code>FLOWFarm.plotsingleboundary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotsingleboundary!(ax, boundary_vertices; color=&quot;k&quot;, linestyle=&quot;-&#39;)

Convenience function for plotting wind farm boundaries</code></pre><p><strong>Arguments</strong></p><ul><li>`ax</li><li><code>boundary_vertices::Array{Float,1}(nvertices)</code>: an nx2 array of boundary vertices for polygon or [[center<em>x, center</em>y], radius] for circle boundary</li><li><code>color::=String</code>: sets color for turbine markers</li><li><code>linestyle::String</code>: sets the line style for the boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL124-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotwindfarm!-NTuple{4, Any}" href="#FLOWFarm.plotwindfarm!-NTuple{4, Any}"><code>FLOWFarm.plotwindfarm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotwindfarm!(ax, boundary_vertices, turbinex, turbiney, rotordiameter; nboundaries=1, aspect=&quot;equal&quot;, xlim=[], ylim=[], fill=false, color=&quot;k&quot;, markeralpha=1, title=&quot;&quot;)

Convenience function for plotting wind farms</code></pre><p><strong>Arguments</strong></p><ul><li>`ax</li><li><code>boundary_vertices::Array{Float,1}(nvertices)</code>: an nx2 array of boundary vertices</li><li><code>turbinex::Array{Float,1}(nturbines)</code>: an array x coordinates of wind turbine locations</li><li><code>turbiney::Array{Float,1}(nturbines)</code>: an array y coordinates of wind turbine locations</li><li><code>rotordiameter::Array{Float,1}(nturbines)</code>: an array rotor diameters of wind turbines</li><li><code>nboundaries::Int</code>: number of discrete boundary regions</li><li><code>aspect::String</code>: set plot aspect ratio, default=&quot;equal&quot;</li><li><code>xlim::Array</code>: limits in x coordinate. &quot;[]&quot; results in limits being automatically defined</li><li><code>ylim::Array</code>: limits in y coordinate. &quot;[]&quot; results in limits being automatically defined</li><li><code>fill::Bool</code>: determines whether turbine circle markers are filled or not</li><li><code>color::=String</code>: sets color for turbine markers</li><li><code>markeralpha::Int</code>: determines tranparancy of turbine markers</li><li><code>title::String</code>: optional title to include on the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL14-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotwindresource!-Tuple{FLOWFarm.DiscretizedWindResource}" href="#FLOWFarm.plotwindresource!-Tuple{FLOWFarm.DiscretizedWindResource}"><code>FLOWFarm.plotwindresource!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotwindresource!(ax::Array, windresource::ff.DiscretizedWindResource; roundingdigits=[1,3], fill=false, alpha=0.5, colors=[&quot;b&quot;, &quot;b&quot;], fontsize=8, edgecolor=nothing, rlabel_position=-45)

Convenience function for visualizing the wind speed and wind frequency roses</code></pre><p><strong>Arguments</strong></p><ul><li><code>ax::Array</code>: pre-initialized single dimension array of axes from pyplot with length at least 2</li><li><code>windresource::ff.DiscretizedWindResource</code>: wind rose information</li><li><code>roundingdigits::Array{Int, 1}</code>: how many significant digits to round to on each axis in ax</li><li><code>fill::Bool</code>: determines whether bars are filled or not</li><li><code>alpha::Number</code>: tranparancy of bars between 0 (transparent) and 1 (opaque)</li><li><code>colors::=Array{String, 1}</code>: sets color for turbine markers</li><li><code>fontsize::Int</code>: font size of text on figures</li><li><code>edgecolor</code>: color of edges of each bar in polar chart, nothing means no color</li><li><code>rlabel_position:Number</code>: Angle at which to draw the radial axes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL219-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.plotwindrose!-Tuple{Any, Any, Any}" href="#FLOWFarm.plotwindrose!-Tuple{Any, Any, Any}"><code>FLOWFarm.plotwindrose!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotwindrose!(ax, d, f; roundingdigit=1, color=&quot;C0&quot;,alpha=0.5,fontsize=8,
dticks=(0,pi/4,pi/2,3*pi/4,pi,5*pi/4,3*pi/2,7*pi/4),
dlabels=(&quot;E&quot;,&quot;NE&quot;,&quot;N&quot;,&quot;NW&quot;,&quot;W&quot;,&quot;SW&quot;,&quot;S&quot;,&quot;SE&quot;),
fticks=nothing, flabels=nothing, normalize=false, edgecolor=nothing, units=&quot;&quot;,
rlabel_position=-45)

Convenience function for creating a windrose from any polar data</code></pre><p><strong>Arguments</strong></p><ul><li><code>ax::PyCall.PyObject</code>: pre-initialized axis from pyplot</li><li><code>d::Vector</code>: wind rose directions</li><li><code>f::Vector</code>: wind rose radial variable</li><li><code>roundingdigit::Int</code>: how many significant digits to round to</li><li><code>fontsize::Int</code>: font size of text on figures</li><li><code>dticks::Tuple</code>: contains angular tick locations</li><li><code>dlabels::Tuple</code>: contains angular tick labels</li><li><code>fticks::Tuple</code>: contains radial tick locations</li><li><code>flabels::Tuple</code>: contains radial tick labels</li><li><code>normalize::Bool</code>: choose whether or not to normalize by the sum of f</li><li><code>units::String</code>: Units to append to flabels</li><li><code>rlabel_position:Number</code>: Angle at which to draw the radial axis</li><li><code>plotcommand::String</code>: Type of plot. Can be [&quot;bar&quot;, &quot;plot&quot;]</li><li><code>kwargs::Tuple</code>: tuple containing key word arguments to plotcommand in the form (key =&gt; &quot;value&quot;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/plotting.jl#LL260-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.point_velocity-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}" href="#FLOWFarm.point_velocity-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}"><code>FLOWFarm.point_velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_velocity(loc, turbine_x, turbine_y, turbine_z, turbine_yaw, turbine_ct, turbine_ai,
rotor_diameter, hub_height, turbine_local_ti, sorted_turbine_index, wtvelocities,
wind_resource, model_set::AbstractModelSet;
wind_farm_state_id=1, downwind_turbine_id=0)</code></pre><p>Calculates the wind speed at a given point for a given state</p><p><strong>Arguments</strong></p><ul><li><code>loc::Array{TF,3}</code>: Location of interest</li><li><code>turbine_x::Array{TF,nTurbines}</code>: turbine east-west locations in the state    reference frame</li><li><code>turbine_y::Array{TF,nTurbines}</code>: turbine north-south locations in the state    reference frame</li><li><code>turbine_z::Array{TF,nTurbines}</code>: turbine base height in the state reference frame</li><li><code>turbine_yaw::Array{TF,nTurbines}</code>: turbine yaw for the given wind direction in    radians</li><li><code>turbine_ct::Array{TF,nTurbines}</code>: turbine thrust coefficients for the given state</li><li><code>turbine_ai::Array{TF,nTurbines}</code>: turbine axial induction for the given state</li><li><code>rotor_diameter::Array{TF,nTurbines}</code>: turbine rotor diameters</li><li><code>hub_height::Array{TF,nTurbines}</code>: turbine hub heights</li><li><code>turbine_local_ti::Array{TF,nTurbines}</code>: turbine local turbulence intensity for    the given state</li><li><code>sorted_turbine_index::Array{TF,nTurbines}</code>: array containing indices of wind turbines    from most upwind to most downwind turbine in the given state</li><li><code>wtvelocities::Array{TF,nTurbines}</code>: effective inflow wind speed for given state</li><li><code>wind_resource::DiscretizedWindResource</code>: contains wind resource discreption (directions,   speeds, frequencies, etc)</li><li><code>wind_farm_state_id::Int</code>: index to correct state to use from wind resource provided.   Defaults to 1</li><li><code>downwind_turbine_id::Int</code>: index of wind turbine of interest (if any). If not a point for   calculating effective wind speed of a turbine, then provide 0 (default)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/general_models.jl#LL25-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.pointinpolygon" href="#FLOWFarm.pointinpolygon"><code>FLOWFarm.pointinpolygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pointinpolygon(point, vertices, normals=nothing; s=700, method=&quot;raycasting&quot;, shift=1E-10, return_distance=true)</code></pre><p>Given a polygon determined by a set of vertices, determine the signed distance from the point  to the polygon. </p><p>Returns the negative (-) distance if the point is inside or on the polygon, positive (+)  otherwise. If return_distance is set to false, then returns -1 if in polygon or on the  boundary, and 1 otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>point::Vector{Number}(2)</code>: point of interest</li><li><code>vertices::Vector{Matrix{Number}(2)</code>: vertices of polygon</li><li><code>normals::Vector{Matrix{Number}(2)</code>: if not provided, they will be calculated</li><li><code>s::Number</code>: smoothing factor for ksmax function (smoothmax)</li><li><code>method::String</code>: currently only raycasting is available</li><li><code>shift::Float</code>: how far to shift point if it lies on an edge or vertex</li><li><code>return_distance::Bool</code>: if true, return distance. if false, return -1 if in polygon or on the boundary, and 1 otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL1280-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.pointonline-Tuple{Any, Any, Any}" href="#FLOWFarm.pointonline-Tuple{Any, Any, Any}"><code>FLOWFarm.pointonline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointonline(p, v1, v2; tol=1E-6)</code></pre><p>Given a line determined two points (v1 and v2) determine if the point (p) lies on the line between those points. </p><p>Returns true if the point lies on the line (within the given tolerance), false otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>p::Vector{Number}(2)</code>: point of interest</li><li><code>v1::Vector{Number}(2)</code>: first vertex of the line</li><li><code>v2::Vector{Number}(2)</code>: second vertex of the line</li><li><code>tol::Number</code>: how close the cumulative distance from v1 to p to v2 must be to the distance from v1 to v2 to count as being co-linear</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL1255-L1268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.print_layout_in_cartesian_frame_excel-NTuple{5, Any}" href="#FLOWFarm.print_layout_in_cartesian_frame_excel-NTuple{5, Any}"><code>FLOWFarm.print_layout_in_cartesian_frame_excel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_state_layouts_in_cartesian_frame(turbinex, turbiney, winddirections)</code></pre><p>Given a wind farm layout in the global reference frame, print the layout rotated to the  cartesian frame with wind to the positive x axis (right) for all wind directions.</p><p><strong>Arguments</strong></p><ul><li><code>turbinex::Array{T,1}</code>: x locations of turbines in global reference frame </li><li><code>turbiney::Array{T,1}</code>: y locations of turbines in global reference frame</li><li><code>winddirections::Array{T,1}</code>: all wind directions in radians in meteorological coordinates (0 rad. = from North)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL686-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.rainflow" href="#FLOWFarm.rainflow"><code>FLOWFarm.rainflow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rainflow(array_ext,uc_mult=0.5)</code></pre><p>Rainflow counting of a signal&#39;s turning points</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">    array_ext (numpy.ndarray): array of turning points</code></pre><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">    uc_mult (float): partial-load scaling [opt, default=0.5]</code></pre><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">    array_out (numpy.ndarray): (3 x n_cycle) array of rainflow values:
                                1) load range
                                2) range mean
                                3) cycle count</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/fatigue_model.jl#LL212-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.ray_casting_boundary-NTuple{4, Any}" href="#FLOWFarm.ray_casting_boundary-NTuple{4, Any}"><code>FLOWFarm.ray_casting_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ray_casting_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)</code></pre><p>Calculate the distance from each turbine to the nearest point on the boundary using  the ray-casting algorithm. Negative means the turbine is inside the boundary.</p><p><strong>Arguments</strong></p><ul><li><code>boundary_vertices::Array{Float,2}</code>: vertices of the boundary CCW in order s.t.       boundaryVertices[i] -&gt; first point of face for unit_normals[i]</li><li><code>boundary_normals::Array{Float,2}</code>: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face</li><li><code>turbine_x::Array{Float}</code>: turbine x locations</li><li><code>turbine_y::Array{Float}</code>: turbine y locations</li><li><code>discrete::Bool</code>: if true, indicates the boundary is made of multiple discrete regions</li><li><code>s::Number</code>: smoothing factor for smooth max (ksmax)</li><li><code>tol::Float</code>: how close points have to be to vertex or face before they will be shifted slightly to avoid a discontinuity</li><li><code>return_region::bool</code>: if true, return a vector specifying which region each turbine is in</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL307-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.rediscretize_windrose-Tuple{FLOWFarm.DiscretizedWindResource, Any}" href="#FLOWFarm.rediscretize_windrose-Tuple{FLOWFarm.DiscretizedWindResource, Any}"><code>FLOWFarm.rediscretize_windrose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rediscretize_windrose(windrosein::DiscretizedWindResource, ndirectionbins, nspeedbins)

Function for re-interpreting a wind rose into a desired number of bins. Returns the new
wind rose. Currently only works for windroses with a single speed in each direction.</code></pre><p><strong>Arguments</strong></p><ul><li><code>windrosein::DiscretizedWindResource</code>: original wind rose</li><li><code>ndirectionbins::Integer</code>: number of direction bins for the new wind rose</li><li><code>start::Float</code>: direction for first bin in radians</li><li><code>averagespeed::Bool</code>: set whether or not to return the average wind speed as the speed for all bins</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wind_resources.jl#LL31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.rotate_to_wind_direction-Tuple{Any, Any, Number}" href="#FLOWFarm.rotate_to_wind_direction-Tuple{Any, Any, Number}"><code>FLOWFarm.rotate_to_wind_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_to_wind_direction(xlocs, ylocs, wind_direction_met)</code></pre><p>Rotates wind farm coordinates to be in wind direction reference where wind direction is to the positive x.</p><p><strong>Arguments</strong></p><ul><li><code>xlocs::Array</code>: contains turbine east-west locations in the global reference frame</li><li><code>ylocs::Array</code>: contains turbine north-south locations in the global reference frame</li><li><code>wind_direction_met::Array</code>: contains wind direction in radians in meteorological standard    system (N=0 rad, proceeds CW, wind from direction given)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.rotor_sample_points" href="#FLOWFarm.rotor_sample_points"><code>FLOWFarm.rotor_sample_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotor_sample_points(nsamplepoints=1)</code></pre><p>Initializes the sampling locations in the rotor-swept-area. Returns values such that zero is at the turbine hub location and 1 is at the tip of the blades. If a single sample is requested, it will be at the hub location. Otherwise, the points will be located using the sunflower packcing algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>nsamplepoints::Int</code>: controlls how many sample points to generate</li><li><code>alpha::Float</code>: Controls smoothness of the sunflower algorithm boundary. alpha=0 is the standard &quot;jagged edge&quot; sunflower algoirthm and   alpha=1 results in a smooth boundary.</li><li><code>pradius::Float</code>: the percent of the rotor radius to use in generating initial point grid </li><li><code>use_perimeter_points</code>: whether or not to include point exactly on the perimeter of the    rotor swept area </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL647-L662">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.round_farm_random_start-Tuple{Any, Any, Any}" href="#FLOWFarm.round_farm_random_start-Tuple{Any, Any, Any}"><code>FLOWFarm.round_farm_random_start</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round_farm_random_start(rotor_diameter, center, radius; min_spacing=2., min_spacing_random=3., method=&quot;individual&quot;)</code></pre><p>Generates starting locations for multi-start optimization approaches when the farm boundary is round.</p><p><strong>Arguments</strong></p><ul><li><code>rotor_diameter::Number</code>: wind turbine diameter </li><li><code>center::Number</code>: wind farm center</li><li><code>radius::Number</code>: wind farm radius</li><li><code>diameter::Array{T,1}</code>: diameters of all wind turbines</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL923-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.smooth_max-Tuple{Any, Any}" href="#FLOWFarm.smooth_max-Tuple{Any, Any}"><code>FLOWFarm.smooth_max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth_max_ndim(x; s=100.0)</code></pre><p>Calculate the smooth-max (a.k.a. softmax or LogSumExponential) of the elements in x.</p><p>Based on John D. Cook&#39;s writings at  (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/</p><p><strong>Arguments</strong></p><ul><li><code>x::Float</code>: first value for comparison</li><li><code>y::Float</code>: second value for comparison</li><li><code>s::Float</code> : controls the level of smoothing used in the smooth max</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL225-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.smooth_max-Tuple{Any}" href="#FLOWFarm.smooth_max-Tuple{Any}"><code>FLOWFarm.smooth_max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smooth_max(x; s=10.0)</code></pre><p>Calculate the smoothmax (a.k.a. softmax or LogSumExponential) of the elements in x.</p><p>Based on John D. Cook&#39;s writings at  (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/</p><p>And based on article in FeedlyBlog (3) https://blog.feedly.com/tricks-of-the-trade-logsumexp/</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{Float,1}</code> : vector with all the input values</li><li><code>s::Float</code> : controls the level of smoothing used in the smooth max</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL255-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.splined_boundary-NTuple{5, Any}" href="#FLOWFarm.splined_boundary-NTuple{5, Any}"><code>FLOWFarm.splined_boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splined_boundary(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)</code></pre><p>calculate the distance from each turbine to a closed boundary made up of zero or more reflex angles (concavities). Boundary will have three or four user-selected &quot;corners&quot;, such that the &quot;sides&quot; between corners (that will be splined) are injective functions (meaning that for every x-coord, there exists only one corresponding y-coord). Returns four values for every turbine, corresponding to the distance from the turb to the upper, lower, left, and right splined &quot;sides&quot;. A negative return value means the turb is inside the boundary for that &quot;side&quot;. Returns a single array of {Float64} of length {length(turbine_x) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float}</code>: turbine x locations</li><li><code>turbine_y::Array{Float}</code>: turbine y locations</li><li><code>bndry_x_clsd::Array{Float}</code>: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.</li><li><code>bndry_y_clsd::Array{Float}</code>: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.</li><li><code>bndry_corner_indcies::Array{Float}</code>: An array of 3 or 4 indicies in the       bndry<em>x/y</em>clsd arrays that correspond to the three four &quot;corners&quot; used       between splined &quot;sides&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL93-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.splined_boundary_discreet_regions-NTuple{7, Any}" href="#FLOWFarm.splined_boundary_discreet_regions-NTuple{7, Any}"><code>FLOWFarm.splined_boundary_discreet_regions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splined_boundary_discreet_regions(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbs_per_region)</code></pre><p>Uses FLOWFarm&#39;s splined<em>boundary() function to calculate the turbine-boundary constraints for one or more discreet regions, with pre-allocated turbines for each region. Returns four values for every turbine, corresponding to the distance from each turb to the upper, lower, left, and right splined &quot;sides&quot; for the region to which it was allocated. A negative return value means the turb is outside the &quot;side&quot; of boundary for which it has been allocated. Returns a single array of {Float64} of length {length(turbine</em>x) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float}</code>: turbine x locations</li><li><code>turbine_y::Array{Float}</code>: turbine y locations</li><li><code>bndry_x_clsd::Array{Float}</code>: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.</li><li><code>bndry_y_clsd::Array{Float}</code>: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.</li><li><code>bndry_corner_indcies::Array{Float}</code>: An array of 3 or 4 indicies in the       bndry<em>x/y</em>clsd arrays that correspond to the three four &quot;corners&quot; used       between splined &quot;sides&quot;</li><li>&#39;turbs<em>per</em>region::Array{Int}`: An array of length equivalent to the number of       discrete boundary regions, with each element denoting howmany turbines       are apportioned to the corresponding region. sum(turbs<em>per</em>region) must       be equivalent to the total number of turbines in the windfarm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL152-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.sunflower_points-Tuple{Any}" href="#FLOWFarm.sunflower_points-Tuple{Any}"><code>FLOWFarm.sunflower_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sunflower_points(n; alpha=0.0)</code></pre><p>Generates points in a circle of radius=1 using the sunflower packing algorithm. </p><p><strong>Arguments</strong></p><ul><li><code>n::Float</code>: number of points to generate</li><li><code>alpha::Float</code>: Controls the smoothness of the boundary. alpha=0 is the standard &quot;jagged edge&quot; sunflower algoirthm and   alpha=1 results in a smooth boundary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL570-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.turbine_powers_one_direction-NTuple{10, Any}" href="#FLOWFarm.turbine_powers_one_direction-NTuple{10, Any}"><code>FLOWFarm.turbine_powers_one_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">turbine_powers_one_direction((generator_efficiency, cut_in_speed, cut_out_speed, 
    rated_speed, rated_power, rotor_diameter, turbine_inflow_velcities, air_density, power_model::AbstractPowerModel)</code></pre><p>Calculate the power for all wind turbines for a given state</p><p><strong>Arguments</strong></p><ul><li><code>generator_efficiency::Array{Float,nTurbines}</code></li><li><code>cut_in_speed::Array{Float,nTurbines}</code> </li><li><code>cut_out_speed::Array{Float,nTurbines}</code></li><li><code>rated_speed::Array{Float,nTurbines}</code></li><li><code>rated_power::Array{Float,nTurbines}</code></li><li><code>rotor_diameter::Array{Float,nTurbines}</code></li><li><code>turbine_inflow_velcities::Array{Float,nTurbines}</code>: for current state only</li><li><code>air_density::Float</code></li><li><code>power_models::Array{nturbines})</code> elements of array should be be of sub-types or AbstractPowerModel</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/power_models.jl#LL319-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.turbine_spacing-Tuple{Any, Any}" href="#FLOWFarm.turbine_spacing-Tuple{Any, Any}"><code>FLOWFarm.turbine_spacing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">turbine_spacing(turbine_x,turbine_y)</code></pre><p>Calculate the distance between turbines in a wind farm. There is an infinite gradient of this function if two points are exactly the same. This can be avoided by returning the square of the turbine spacing rather than the actual distance, but it makes the gradients scale much more poorly. Because it is very vanishingly rare to have turbines exactly in the same location, this function leaves the square root in the calculations.</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{Float}</code>: turbine x locations</li><li><code>turbine_y::Array{Float}</code>: turbine y locations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/optimization_functions.jl#LL7-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.turbine_velocities_one_direction-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}" href="#FLOWFarm.turbine_velocities_one_direction-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}"><code>FLOWFarm.turbine_velocities_one_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_velocity(turbine_x, turbine_y, turbine_z, rotor_diameter, hub_height, turbine_yaw,
sorted_turbine_index, ct_model, rotor_sample_points_y, rotor_sample_points_z, wind_resource,
model_set::AbstractModelSet; wind_farm_state_id=1)</code></pre><p>Calculates the wind speed at a given point for a given state</p><p><strong>Arguments</strong></p><ul><li><code>turbine_x::Array{TF,nTurbines}</code>: turbine east-west locations in the state    reference frame</li><li><code>turbine_y::Array{TF,nTurbines}</code>: turbine north-south locations in the state    reference frame</li><li><code>turbine_z::Array{TF,nTurbines}</code>: turbine base height in the state reference frame</li><li><code>rotor_diameter::Array{TF,nTurbines}</code>: turbine rotor diameters</li><li><code>hub_height::Array{TF,nTurbines}</code>: turbine hub heights</li><li><code>turbine_yaw::Array{TF,nTurbines}</code>: turbine yaw for the given wind direction in    radians</li><li><code>sorted_turbine_index::Array{TF,nTurbines}</code>: turbine sorted order upstream to downstream    for given state</li><li><code>ct_model::AbstractThrustCoefficientModel</code>: defines how the thrust coefficient changes    with state etc</li><li>rotor<em>sample</em>points_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) </li><li>rotor<em>sample</em>points_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)</li><li><code>wind_resource::DiscretizedWindResource</code>: wind resource discreption (directions, speeds,    frequencies, etc)</li><li><code>model_set::AbstractModelSet</code>: defines wake-realated models to be used in analysis</li><li><code>wind_farm_state_id::Int</code>: index to correct state to use from wind resource provided.   Defaults to 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/general_models.jl#LL138-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_count_iec-Tuple{Any, Any, Real, Any}" href="#FLOWFarm.wake_count_iec-Tuple{Any, Any, Real, Any}"><code>FLOWFarm.wake_count_iec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_count_iec(turbinex, turbiney, winddirection, diameter; return_turbines=true)

Adapted from NREL&#39;s floris

Finds the number of turbines waking each turbine for the given
wind direction. Waked directions are determined using the formula
in Figure A.1 in Annex A of the IEC 61400-12-1:2017 standard.</code></pre><p><strong>Arguments</strong></p><ul><li><code>turbinex::Array{T,1}</code>: x locations of turbines in global reference frame </li><li><code>turbiney::Array{T,1}</code>: y locations of turbines in global reference frame</li><li><code>winddirection::Float</code>: wind direction in radians in meteorological coordinates (0 rad. = from North)</li><li><code>diameter::Array{T,1}</code>: diameters of all wind turbines</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/utilities.jl#LL758-L772">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussOriginal}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussOriginal}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussOriginal)</code></pre><p>Computes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: &quot;A new analytical model for wind-turbine wakes&quot; (2014)</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::GaussOriginal</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL419-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussSimple}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussSimple}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussSimple)</code></pre><p>Computes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: &quot;A new analytical model for wind-turbine wakes&quot; (2014)     as modified for IEA Task 37 Case Studies 3 and 4</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::GaussSimple</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL670-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpread}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpread}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYawVariableSpread)</code></pre><p>Computes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: &quot;Experimental and theoretical study of wind turbine wakes in yawed conditions&quot; (2016) The spread rate is adjusted based on local turbulence intensity as in Niayifar and Porte-Agel 2016</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::GaussYawVariableSpread</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL619-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYaw}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYaw}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYaw)</code></pre><p>Computes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: &quot;Experimental and theoretical study of wind turbine wakes in yawed conditions&quot; (2016)</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::GaussYaw</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL568-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenCosine}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenCosine}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenCosine)</code></pre><p>Computes the wake deficit according to the original Jensen cosine wake model, from the paper: &quot;A Note on Wind Generator Interaction&quot; by N.O. Jensen (1983)</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::JensenCosine</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL208-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenTopHat}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenTopHat}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenTopHat)</code></pre><p>Computes the wake deficit according to the original Jensen top hat wake model, from the paper: &quot;A Note on Wind Generator Interaction&quot; by N.O. Jensen (1983)</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::JensenTopHat</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL126-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.MultiZone}" href="#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.MultiZone}"><code>FLOWFarm.wake_deficit_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::MultiZone)</code></pre><p>Computes the wake deficit at a given location using the original MultiZone &quot;FLORIS&quot; wake model, from the paper: &quot;Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study&quot; by Gebraad et al. (2014)</p><p><strong>Arguments</strong></p><ul><li><code>locx::Float</code>: x coordinate where wind speed is calculated </li><li><code>locy::Float</code>: y coordinate where wind speed is calculated</li><li><code>locz::Float</code>: z coordinate where wind speed is calculated</li><li><code>turbine_x::Array(Float)</code>: vector containing x coordinates for all turbines in farm</li><li><code>turbine_y::Array(Float)</code>: vector containing y coordinates for all turbines in farm</li><li><code>turbine_z::Array(Float)</code>: vector containing z coordinates for all turbines in farm</li><li><code>deflection_y::Float</code>: deflection in the y direction of downstream wake </li><li><code>deflection_z::Float</code>: deflection in the z direction of downstream wake </li><li><code>upstream_turbine_id::Int</code>: index of the upstream wind turbine creating the wake</li><li><code>downstream_turbine_id::Int</code>: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)</li><li><code>hub_height::Array(Float)</code>: vector containing hub heights for all turbines in farm</li><li><code>rotor_diameter::Array(Float)</code>: vector containing rotor diameters for all turbines in farm</li><li><code>turbine_ai::Array(Float)</code>: vector containing initial velocity deficits for all turbines in farm</li><li><code>turbine_local_ti::Array(Float)</code>: vector containing local turbulence intensities for all turbines in farm</li><li><code>turbine_ct::Array(Float)</code>: vector containing thrust coefficients for all turbines in farm</li><li><code>turbine_yaw::Array(Float)</code>: vector containing the yaw angle? for all turbines in farm</li><li><code>model::MultiZone</code>: indicates the wake model in use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deficit_models.jl#LL268-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawDeflection}" href="#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawDeflection}"><code>FLOWFarm.wake_deflection_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deflection_model(locx, locy, locz, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawDeflection)

Calculates the horizontal deflection of the wind turbine wake

Based on:
[1] Bastankhah and Porte-Agel 2016 &quot;Experimental and theoretical study of
wind turbine wakes in yawed conditions&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL184-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpreadDeflection}" href="#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpreadDeflection}"><code>FLOWFarm.wake_deflection_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deflection_model(oc, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawVariableSpreadDeflection)

Calculates the horizontal deflection of the wind turbine wake. Varies based on local turbulence intensity.

Based on:
[1] Bastankhah and Porte-Agel 2016 &quot;Experimental and theoretical study of
wind turbine wakes in yawed conditions&quot;
[2] Niayifar and Porte-Agel 2016 &quot;Analytical Modeling of Wind Farms:
A New Approach for Power Prediction&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL227-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JiminezYawDeflection}" href="#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JiminezYawDeflection}"><code>FLOWFarm.wake_deflection_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::JiminezYawDeflection)

Calculates the horizontal deflection of the wind turbine wake

Based on:
[1] Jiminez 2010 &quot;Wake defl ection of a wind turbine in yaw&quot;
[2] Gebraad 2014 &quot;Wind plant optimization by yaw control using a parametric wake model&quot;
this version ignores the corrections made to the yaw model for rotor rotation as described in [2] and
[3] Thomas 2017 &quot;Improving the FLORIS wind plant model for compatibility with gradient-based optimization&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.NoYawDeflection}" href="#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.NoYawDeflection}"><code>FLOWFarm.wake_deflection_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::NoYawDeflection, windfarmstate::SingleWindFarmState)

Bypasses yaw deflection calculations.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/wake_deflection_models.jl#LL80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FLOWFarm.write_turb_loc_YAML-Tuple{Any, Any, Any}" href="#FLOWFarm.write_turb_loc_YAML-Tuple{Any, Any, Any}"><code>FLOWFarm.write_turb_loc_YAML</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_turb_loc_YAML(file_name, data)</code></pre><p>write turbine locations and related information to .yaml</p><p><strong>Arguments</strong></p><ul><li><code>file_name::String</code>: path/and/name/of/location/file.yaml</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/c45282d244e4c1f076d5cb99a95550cd3bd1fe7e/src/io.jl#LL123-L130">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Explanation/">« Theory</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 23 March 2022 22:25">Wednesday 23 March 2022</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
